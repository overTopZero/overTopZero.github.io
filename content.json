{"meta":{"title":"Craco的博客","subtitle":"一个热爱编程的程序猿","description":"辽宁科技大学08级, 就职于上海宏驰, 擅长iOS, web前端, 非专业视觉设计师。此为博客一枚。","author":"Craco","url":"http://zhulele90.cn"},"pages":[],"posts":[{"title":"Swift5基本语法三-- 枚举、可选项","slug":"Swift5基本语法三-枚举、可选项","date":"2019-07-11T08:08:26.000Z","updated":"2019-07-11T08:16:34.634Z","comments":true,"path":"2019/07/11/Swift5基本语法三-枚举、可选项/","link":"","permalink":"http://zhulele90.cn/2019/07/11/Swift5基本语法三-枚举、可选项/","excerpt":"枚举","text":"枚举 基本用法123enum Direction &#123; case north, south, east, west&#125; 关联值(Associated Values) 将枚举的成员值跟其他类型的关联储存在一起，会非常有用 12345678910111213141516171819202122232425262728293031323334enum Date &#123; case digit(year: Int, month: Int, day: Int) case string(String)&#125;var date = Date.digit(year: 2011, month: 9, day: 11)date = .string(\"2019-10-9\")switch date &#123;case .digit(let year, let month, let day): print(year,month,day)case let .string(value): print(value)&#125;// let 也可以改为 var~~~ #### 原始值(Raw Value)- 枚举成员可以使用 相同累心 的默认值预先关联，这个默认值就叫做: 原始值 ` enum PokerSuit: Character &#123; case spade = \"A\" &#125;`#### 隐式原始值(Implicitly Assigned Raw Values) - 如果枚举的原始值类型是Int、String,Swift会自动分配原始值 - 如果是字符串，就是名字 - 如果是Int，就是0、1、2~~~swiftenum Direction : String &#123; case north = \"north\" case south = \"south\" case east = \"east\" case west = \"west\"&#125;enum Direction : String &#123; case north, south, east, west&#125;// 这两个枚举写法完全等价 递归枚举(Recursive Enumeration) 在enum前必须加上indirect关键字 indirect enum AS {} MemoryLayout 可以使用MemoryLayout获取数据类型占用的内存大小 123456789101112131415161718// 关联值 - 直接将传入的关联值存储在枚举变量的内存里enum Password &#123; case number(Int, Int, Int, Int) case other&#125;var pwd = Password.number(5, 6, 4, 7)pwd = .otherMemoryLayout&lt;Password&gt;.size //33,实际用到的控件大小--32个字节存储number，一个存储otherMemoryLayout&lt;Password&gt;.stride //40,分配占用的空间大小MemoryLayout&lt;Password&gt;.alignment//8,对齐参数// 原始值 - 和枚举成员绑定的，固定的,并不会将原始值存储到枚举变量内存里enum Direction : Int &#123; case north = 1, south, east, west&#125;var d = Direction.northMemoryLayout&lt;Direction&gt;.size //1MemoryLayout&lt;Direction&gt;.stride //1MemoryLayout&lt;Direction&gt;.alignment//1 可选项(Optional) 可选项，一般也称为可选类型，它允许将值设置为nil 在类型名称后加一个?来定义一个可选项 1var age: Int? //表示的是初始值默认是nil 强制解包(Forced Unwrapping) 可选项是对其他类型的一层包装，可以将它理解为一个盒子 如果为nil，那么他就是个空盒子 如果不是nil，那么盒子里转的是被包装类型的数据 如果要从可选项中取出被包装的数据(将盒子里的东西取出来)，需要使用感叹号!进行强制解包 如果对值为nil的可选项(空盒子)进行强制解包，将会产生运行时错误 可选项绑定(Optional Binding) 可以使用可选项绑定来判断可选项是否包含值 如果包含就会自动解包，把值赋给一个临时的常量或者变量，并返回true，否则返回false 12345if let number = Int(\"123\") &#123; print(\"\\(number)\")&#125; else &#123; print(\"shibai\")&#125; 可选项绑定，多个条件要用”,”区别开来 12345if let number = Int(\"123\"), let s = Int(\"11\") &#123; print(\"\\(number)\")&#125; else &#123; print(\"shibai\")&#125; while循环中使用可选项绑定 12345678910// 遍历数组，将遇到的正数加起来，如果遇到负数或者非数字，停止遍历var strs = [\"10\", \"20\", \"abc\", \"-20\", \"30\"]var index = 0var sum = 0while let num = Int(strs[index]), num &gt; 0 &#123; sum += num index += 1&#125;print(sum) 空合并运算符(Nil-Coalescing Operator) a ?? b a 是可选项 b 是可选项，也可以不是 b 和 a 的存储类型必须相同 如果 a 不为nil，就返回a 如果a 为nil，就返回b 如果b 不是可选项， 返回a 时会自动解包 123let a: Int? = 7let b: Int = 2let c = a ?? b // c 是 Int， 1 a ?? b ?? c 从左往右计算 ?? 和 if let 配合使用 if let c = a ?? b {} guard语句 guard 条件 else { 退出当前作用域 – return/break… } 当guard语句的条件为false时，就会执行大括号里的代码 当guard语句的条件为true时，就会跳过guard语句 guard语句特别适合做提前退出 当使用guard语句进行可选项绑定时，绑定的常量、变量也能在外层作用域中使用 123456789101112// 使用 guard else 实现用户登录func login (_ info: [String : String]) &#123; guard let username = info[\"usernmae\"] else &#123; print(\"请输入用户名\") return &#125; guard let password = info[\"password\"] else &#123; print(\"请输入密码\") return &#125; print(\"用户名: \\(username)\", \"密码: \\(password)\", \"登录中...\")&#125; 隐式解包(Implicitly Unwrapped Optional) 在某些情况下，可选项一旦被设定值之后，就会一直拥有值，在这种情况下，可以去掉检查，也不必每次访问的时候都进行解包，因为它能确定每次访问的时候都有值 可以在类型后面加个感叹号!,定义一个隐式解包的可选项 123// 隐式解包的可选项let num1: Int! = 10let num2: Int = num1 字符串插值 可选项在字符串插值或者直接打印时，编译器会发出警告 var age: Int? = 10; print(&quot;My age is \\(age)&quot;) 三种消除警告的方法 print(&quot;My age is \\(age!)&quot;) print(&quot;My age is \\(String(describing: age))&quot;) print(&quot;My age is \\(age ?? 0)&quot;) 多重可选项123456789101112var num1: Int? = 10var num2: Int?? = num1var num3: Int?? = 10print(num2 == num3) // truevar num1: Int? = nilvar num2: Int?? = num1var num3: Int?? = nilprint(num2 == num3) // falseprint(num1 == num3) // false(num2 ?? 1) ?? 2 // 2(num3 ?? 1) ?? 2 // 1 可以使用lldb指令 frame variable -R 或者 fr v -R 查看区别","categories":[],"tags":[]},{"title":"Swift5基本语法二--流程控制、函数","slug":"Swift5基本语法二-流程控制、函数","date":"2019-07-11T08:08:06.000Z","updated":"2019-07-11T08:16:25.876Z","comments":true,"path":"2019/07/11/Swift5基本语法二-流程控制、函数/","link":"","permalink":"http://zhulele90.cn/2019/07/11/Swift5基本语法二-流程控制、函数/","excerpt":"流程控制","text":"流程控制 if-else123456let age = 5if age &gt;= 22 &#123; print(\"Get married\")&#125; else &#123; print(\"Just a child\")&#125; if 后面的条件可以省略小括号，条件后面的大括号不能省略 if 后面的条件只能是Bool类型 while repeat-while相当于C语言中的do-while for 闭区间运算符: a…b， a &lt;= 取值 &lt;= b 半开区间运算符: a…&lt;b， a &lt;= 取值 &lt; b 123456789101112131415161718let names = [\"Anna\", \"Lele\", \"Brian\", \"Jack\"]for i in 0...3 &#123; print(names[i])&#125; let range = 1...3for i in range &#123; print(names[i])&#125;for var i in 1...3 &#123; i += 5 print(i)&#125;for _ in 1...3 &#123; print(\"for\")&#125;for i in 0...&lt;5 &#123; print(names[i])&#125; 区间运算符用在数组上 单侧区间:让区间朝一个方向尽可能的远 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970let names = [\"Anna\", \"Lele\", \"Brian\", \"Jack\"]for i in names[0...3] &#123; print(i)&#125; for i in names[...2] &#123; print(i)&#125;~~~ - 带间隔的区间值~~~swiftlet hours = 11let hourInterval = 2for tickMark in stride(from: 4, through: hours, by: hourInterval) &#123;print(tickMark)&#125; ~~~ #### switch- case、default后面不能写大括号&#123;&#125;- 默认可以不写break，并不会贯穿到后面的条件- 使用 fallthrough 可以实现贯穿效果- switch注意点 - switch必须保证能处理所有情况 - case、default后面至少要有一条语句 - 如果不想做任何事，加个break即可 - 如果能保证已处理所有的情况，可以不必使用default - case匹配属于模式匹配- switch也支持Character、String类型 - switch 复合条件 case \"Jack\",\"Rose\"- 区间匹配 case 0...3- 元祖匹配 case (0, 0)- 值绑定 case (let x, 0)只要求一方符合- where条件 case let (x, y) where x == y #### 标签语句~~~swiftouter: for i in 1...4 &#123; for k in 1...4 &#123; if k == 3 &#123; continue outer &#125; if i == 3 &#123; break outer &#125; print(\"i == \\(i), k == \\(k)\") &#125;&#125;~~~ ## 函数#### 函数的定义- func pi() -&gt; Double &#123; return 3.14 &#125;- 形参默认是let，也只能 是let- 无返回值 func pi()- 隐式返回 如果整个函数体是一个单一的表达式，那么函数会隐式返回这个表达式 省略return#### 返回元祖: 实现多返回值~~~swiftfunc calculate(v1: Int, v2: Int) -&gt; (sum: Int, difference: Int, average: Int) &#123; let sum = v1 + v2 return (sum, v1 - v2, sum &gt;&gt; 1) // &gt;&gt; 右移取平均值&#125;let result = calculate(v1: 20, v2: 10)result.sum // 30result.difference // 10result.average //15 参数标签 可以修改参数标签 func goToWork(at time: String){} at 用在函数里,是参数标签， time用在函数外 可以使用 省略参数标签 func goToWork( time: String){} 默认参数 (Default Parameter Value) 参数可以有默认值 func check(name: String = “body”) {} C++ 的默认参数数值有个限制: 必须从右向左设置。由于Swift拥有参数标签，因此并没有此类限制 在省略参数标签时，需要特别注意 可变参数(Variadic Parameter)12345678func sum(_ numbers: Int...) -&gt; Int &#123; var total = 0 for number in numbers &#123; total += number &#125; return total&#125;sum(10, 20, 30, 40) // 100 一个函数最多只能有1个可变参数 紧跟在可变参数后面的参数不能省略参数标签 print函数 public func print(_ items: Any…, separator: String = “ “, terminator: String = “\\n”) 输入输出函数(In-Out Parameter) 可以用inout定义一个输入输出函数: 可以在函数内部修改外部实参的值 比如交换两个参数值 func swapValues( v1: inout Int, v2: inout Int) { (v1, v2) = (v2, v1) } 可变参数不能标记inout inout参数不能有默认值 inout参数有些是地址传递(引用传递)，如果传递给inout参数的是计算属性、有监听器的属性等内容，其本质并非引用传递 inout参数只能传入可以被多次赋值的 函数重载(Function Overload) 规则 函数名相同 参数个数不同 || 参数类型不同 || 参数标签不同 注意点 返回值类型与函数重载无关 默认参数值和函数重载一起使用产生二义性时，编译器并不会报错(c++ 报错) 可变参数、省略参数标签、函数重载一起使用产生二义性时，编译器有可能会报错 内联函数(Inline Function) 如果开启了编译器优化(Release模式会默认开启优化), 编译器会自动将某些函数变成内联函数 内联函数将函数调用展开成函数体 哪些函数不会内联 函数体特别长 包含递归调用 包含动态派发(即oc里的动态绑定) 函数类型(Function Type) 每一个函数都是有类型的,函数类型由形参类型、返回值类型组成 函数类型作为函数参数 函数类型作为返回值(返回值是函数类型的函数，叫做高阶函数: Higher-Order Function) typealias 用来给类型起别名 (按照Swift标准库定义, Voide就是空元祖 typealias Void = ()) 嵌套函数 将函数定义在函数内部 @inline 永远不会被内联，即使开启了编译器优化 123@inline(never) func test() &#123; print(\"test\")&#125; 开启编译器优化后，即使代码很长，也会被内联(递归调用函数、动态派发的函数除外) 123@inline(__always) func test() &#123; print(\"test\")&#125; 在Release模式下，编译器已经开启优化，会自动决定哪些函数需要内联，因此没有必要使用@inline","categories":[],"tags":[]},{"title":"Swift5简介和基础语法一","slug":"Swift5简介和基础语法一","date":"2019-07-11T08:06:45.000Z","updated":"2019-07-11T08:07:29.031Z","comments":true,"path":"2019/07/11/Swift5简介和基础语法一/","link":"","permalink":"http://zhulele90.cn/2019/07/11/Swift5简介和基础语法一/","excerpt":"Swift简介 Swift是Apple在2014年6月WWDC发布的全新编程语言，中文名和logo是“雨燕” Swift之父Chris Lattner Clang编译器作者、LLVM项目的主要发起人 从Apple离职后，先后跳槽到Tesla、Google 目前在Google Brain从事AI研究","text":"Swift简介 Swift是Apple在2014年6月WWDC发布的全新编程语言，中文名和logo是“雨燕” Swift之父Chris Lattner Clang编译器作者、LLVM项目的主要发起人 从Apple离职后，先后跳槽到Tesla、Google 目前在Google Brain从事AI研究 Swift版本 Swift5.x版本，ABI稳定 API（Application Programming Interface): 应用程序编程接口 源代码和库之间的接口 ABI (Application Binary Interface)：应用程序二进制接口 应用程序与操作系统之间的底层接口 涉及的内容有:目标文件格式、数据类型的大小、布局、对齐、函数调用约定等等 随着ABI的稳定，Swift语法基本不会再有太大的改动 Swift完全开源: htps://github.com/apple/swift,主要采用C++编写 Swift编译流程Swift Code –&gt; Swift AST –&gt; Raw Swift IL –&gt; Canonical Swift IL –&gt; LLVM IR –&gt; Assembly –&gt; Executable swiftc swiftc存放在Xcode内部 Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin 一些操作 生成语法树：swiftc -dump-ast main.swift 生成最简洁的SIL代码：swiftc -emit-sil main.swift 生成LLVM IR代码： swiftc -emit-ir main.swift -o main.ll 生成汇编代码： swiftc -emit-assembly main.swift -o main.s 对汇编代码进行分析，可以真正掌握编程语言的本质 Playground - View 1234567import UIKitimport PlaygroundSupportlet view = UIView()view.frame = CGRect(x: 0, y: 0, width: 100, height: 100)view.backgroundColor = UIColor.bluePlaygroundPage.current.liveView = view Playground - 注释 单行注释 // 多行注释 / / 多行嵌套注释 / 1 / 3 / 2 / 支持markup语法 添加冒号 //: 等 常量 只能赋值一次 它的值不要求在编译时期确定，但使用之前必须赋值一次 变量、常量在初始化之前，都不能使用 标识符 标识符(比如常量名、变量名、函数名)几乎可以使用任何字符 标识符不能以数字开头，不能包含空白字符、制表符、箭头灯特殊字符 常见数据类型 值类型 (value type) 枚举(enum): Optional 结构体(struct): Bool、Int、Float、Double、Character、String、Array、Dictionary、Set 引用类型 (reference type) 类(class) 字面量 布尔类型 let bool = true 字符串 let string = &quot;Hello word!&quot; 字符（可储存ASCII字符、Unicode字符）let character: Character = &quot;A&quot; 浮点数 let double = 12.0 数组 let array = [1, 3, 3, 4] 字典 let dictionary = [&quot;age&quot;: 19, &quot;height&quot;: 123] 元祖(tuple)12345678910let http404Error = (404, \"Not Found\")print(\"The status code is \\(http404Error.0)\")let (statusCode, statusMessage) = http404Errorprint(\"The status code is \\(statusCode)\")let (justTheStatusCode, _) = http404Errorlet http200Status = (statusCode: 200, description: \"OK\")print(\"The status code is \\(http200Status.description)\")","categories":[],"tags":[{"name":"Swift5 iOS","slug":"Swift5-iOS","permalink":"http://zhulele90.cn/tags/Swift5-iOS/"}]},{"title":"iOS行距调整","slug":"iOS行距调整","date":"2018-06-08T09:09:10.000Z","updated":"2018-06-08T09:13:03.000Z","comments":true,"path":"2018/06/08/iOS行距调整/","link":"","permalink":"http://zhulele90.cn/2018/06/08/iOS行距调整/","excerpt":"行距","text":"行距 iOS 行距调整以前总是很烦设计师非要说，让『把行距调大一点点』，因为在 iOS 这个对文字处理各种不友好的系统里，改行距并不像改字号那么简单，只调『一点点』也得多写好几行。不过自从我写了下面这些工具方法，调行距也就回归到它本来应该的样子:一行代码的事。 设置行距UILabel+Utils.m1234567891011121314151617- (void)setText:(NSString*)text lineSpacing:(CGFloat)lineSpacing &#123; if (lineSpacing &lt; 0.01 || !text) &#123; self.text = text; return; &#125; NSMutableAttributedString *attributedString = [[NSMutableAttributedString alloc] initWithString:text]; [attributedString addAttribute:NSFontAttributeName value:self.font range:NSMakeRange(0, [text length])]; NSMutableParagraphStyle *paragraphStyle = [[NSMutableParagraphStyle alloc] init]; [paragraphStyle setLineSpacing:lineSpacing]; [paragraphStyle setLineBreakMode:self.lineBreakMode]; [paragraphStyle setAlignment:self.textAlignment]; [attributedString addAttribute:NSParagraphStyleAttributeName value:paragraphStyle range:NSMakeRange(0, [text length])]; self.attributedText = attributedString;&#125; 使用1[label setText:text lineSpacing:2.0f]; UITextView+Utils.m123456789101112131415- (void)setText:(NSString*)text lineSpacing:(CGFloat)lineSpacing &#123; if (lineSpacing &lt; 0.01 || !text) &#123; self.text = text; return; &#125; NSMutableAttributedString *attributedString = [[NSMutableAttributedString alloc] initWithString:text]; [attributedString addAttribute:NSFontAttributeName value:self.font range:NSMakeRange(0, [text length])]; NSMutableParagraphStyle *paragraphStyle = [[NSMutableParagraphStyle alloc] init]; [paragraphStyle setLineSpacing:lineSpacing]; [attributedString addAttribute:NSParagraphStyleAttributeName value:paragraphStyle range:NSMakeRange(0, [attributedText length])]; self.attributedText = attributedString;&#125; 使用1[textView setText:text lineSpacing:2.0f]; 计算行高UILabel+Utils.m12345678+ (CGFloat)text:(NSString*)text heightWithFontSize:(CGFloat)fontSize width:(CGFloat)width lineSpacing:(CGFloat)lineSpacing &#123; UILabel* label = [[UILabel alloc] initWithFrame:CGRectMake(0, 0, width, MAXFLOAT)]; label.font = [UIFont systemFontOfSize:fontSize]; label.numberOfLines = 0; [label setText:text lineSpacing:lineSpacing]; [label sizeToFit]; return label.height;&#125; UITextView+Utils.m1234567+ (CGFloat)text:(NSString*)text heightWithFontSize:(CGFloat)fontSize width:(CGFloat)width lineSpacing:(CGFloat)lineSpacing &#123; UITextView* textView = [[UITextView alloc] initWithFrame:CGRectMake(0, 0, width, MAXFLOAT)]; textView.font = [UIFont systemFontOfSize:fontSize]; [textView setText:text lineSpacing:lineSpacing]; [textView sizeToFit]; return textView.height;&#125; 因为默认的 UITextView 有一点 inset，所以计算文本高度的方法要跟 UILabel 分开。 代码上的行距 vs 设计图上的行距代码传参数进去的行距与设计图上量出来的行距是有区别的，代码上要少几个像素，而减少的量跟字体大小有关。 例如一个 UILabel 字号为14，有些程序员可能就会把这个 Label 高度定为 14 像素了。而经验丰富的人就会知道不能这样，否则『h』『g』之类的字母都可能会被切掉一些。在 xib 里，选中 label 之后按『Command + =』会发现字号为 14 的 label 合适的高度应该是 17。 为了给像『g』、『y』英文字母的尾巴留出空间，系统会给 UILabel 上的文字上下加一点默认的空白，这就是 font size 与 line height 的区别。而用代码设定’paragraphStyle的lineSpacing，是叠加在原有空白之上的。 别小看这点空白。如果设计师没有丧心病狂，设计出的行距往往也就是 4、5 个像素，而对 14 号字来说上下两行的空白就能占到 3 像素。如果不假思索地直接把设计图的标注传进去，结果就是行距放大到150%。视觉上出了偏差，我们也要负责任的。 视觉上的行距其实由 3 部分组成：上面一行的默认空白 + 行距 + 下面一行的默认空白。蓝色高度是我们写的 lineSpacing，而黄色和绿色加起来正好是一倍font.lineHeight - font.pointSize的值（黄色高度是上面一行的一半，为(font.lineHeight - font.pointSize) / 2，绿色是下面一行的一半）。 为了计算效率高，我们就不在运行时现算这个差值了；直接把设计图上量出的行距减去上面这个表里几个像素的差值，作为参数传进去即可。例如：14 号字的 label，设计图上量出的行距是 5 个像素，那就减去 3 个像素，写[label setText:text lineSpacing:2.0f];。不要忘了计算行高的时候也要用同样的参数~","categories":[],"tags":[]},{"title":"图层","slug":"图层","date":"2018-06-08T08:32:08.000Z","updated":"2018-06-08T08:37:01.000Z","comments":true,"path":"2018/06/08/图层/","link":"","permalink":"http://zhulele90.cn/2018/06/08/图层/","excerpt":"iOS图层","text":"iOS图层 图层的树状结构 巨妖有图层，洋葱也有图层，你懂吗？我们都有图层 – 史莱克 Core Animation其实是一个令人误解的命名。你可能认为它只是用来做动画的，但实际上它是从一个叫做Layer Kit这么一个不怎么和动画有关的名字演变而来，所以做动画这只是Core Animation特性的冰山一角。 Core Animation是一个复合引擎，它的职责就是尽可能快地组合屏幕上不同的可视内容，这个内容是被分解成独立的图层，存储在一个叫做图层树的体系之中。于是这个树形成了UIKit以及在iOS应用程序当中你所能在屏幕上看见的一切的基础。 在我们讨论动画之前，我们将从图层树开始，涉及一下Core Animation的静态组合以及布局特性。 图层和视图如果你曾经在iOS或者Mac OS平台上写过应用程序，你可能会对视图的概念比较熟悉。一个视图就是在屏幕上显示的一个矩形块（比如图片，文字或者视频），它能够拦截类似于鼠标点击或者触摸手势等用户输入。视图在层级关系中可以互相嵌套，一个视图可以管理它的所有子视图的位置。图1.1显示了一种典型的视图层级关系 图1.1 一种典型的iOS屏幕（左边）和形成视图的层级关系（右边） 在iOS当中，所有的视图都从一个叫做UIVIew的基类派生而来，UIView可以处理触摸事件，可以支持基于Core Graphics绘图，可以做仿射变换（例如旋转或者缩放），或者简单的类似于滑动或者渐变的动画。 CALayerCALayer类在概念上和UIView类似，同样也是一些被层级关系树管理的矩形块，同样也可以包含一些内容（像图片，文本或者背景色），管理子图层的位置。它们有一些方法和属性用来做动画和变换。和UIView最大的不同是CALayer不处理用户的交互。 CALayer并不清楚具体的响应链（iOS通过视图层级关系用来传送触摸事件的机制），于是它并不能够响应事件，即使它提供了一些方法来判断是否一个触点在图层的范围之内（具体见第三章，“图层的几何学”） 平行的层级关系每一个UIview都有一个CALayer实例的图层属性，也就是所谓的backing layer，视图的职责就是创建并管理这个图层，以确保当子视图在层级关系中添加或者被移除的时候，他们关联的图层也同样对应在层级关系树当中有相同的操作（见图1.2）。 图1.2 图层的树状结构（左边）以及对应的视图层级（右边） 实际上这些背后关联的图层才是真正用来在屏幕上显示和做动画，UIView仅仅是对它的一个封装，提供了一些iOS类似于处理触摸的具体功能，以及Core Animation底层方法的高级接口。 但是为什么iOS要基于UIView和CALayer提供两个平行的层级关系呢？为什么不用一个简单的层级来处理所有事情呢？原因在于要做职责分离，这样也能避免很多重复代码。在iOS和Mac OS两个平台上，事件和用户交互有很多地方的不同，基于多点触控的用户界面和基于鼠标键盘有着本质的区别，这就是为什么iOS有UIKit和UIView，但是Mac OS有AppKit和NSView的原因。他们功能上很相似，但是在实现上有着显著的区别。 绘图，布局和动画，相比之下就是类似Mac笔记本和桌面系列一样应用于iPhone和iPad触屏的概念。把这种功能的逻辑分开并应用到独立的Core Animation框架，苹果就能够在iOS和Mac OS之间共享代码，使得对苹果自己的OS开发团队和第三方开发者去开发两个平台的应用更加便捷。 实际上，这里并不是两个层级关系，而是四个，每一个都扮演不同的角色，除了视图层级和图层树之外，还存在呈现树和渲染树，将在第七章“隐式动画”和第十二章“性能调优”分别讨论。 ##图层的能力如果说CALayer是UIView内部实现细节，那我们为什么要全面地了解它呢？苹果当然为我们提供了优美简洁的UIView接口，那么我们是否就没必要直接去处理Core Animation的细节了呢？ 某种意义上说的确是这样，对一些简单的需求来说，我们确实没必要处理CALayer，因为苹果已经通过UIView的高级API间接地使得动画变得很简单。 但是这种简单会不可避免地带来一些灵活上的缺陷。如果你略微想在底层做一些改变，或者使用一些苹果没有在UIView上实现的接口功能，这时除了介入Core Animation底层之外别无选择。 我们已经证实了图层不能像视图那样处理触摸事件，那么他能做哪些视图不能做的呢？这里有一些UIView没有暴露出来的CALayer的功能： 阴影，圆角，带颜色的边框 3D变换 非矩形范围 透明遮罩 多级非线性动画 我们将会在后续章节中探索这些功能，首先我们要关注一下在应用程序当中CALayer是怎样被利用起来的。 使用图层首先我们来创建一个简单的项目，来操纵一些layer的属性。打开Xcode，使用Single View Application模板创建一个工程。 在屏幕中央创建一个小视图（大约200 X 200的尺寸），当然你可以手工编码，或者使用Interface Builder（随你方便）。确保你的视图控制器要添加一个视图的属性以便可以直接访问它。我们把它称作layerView。 运行项目，应该能在浅灰色屏幕背景中看见一个白色方块（图1.3），如果没看见，可能需要调整一下背景window或者view的颜色 图1.3 灰色背景上的一个白色UIView 这并没有什么令人激动的地方，我们来添加一个色块，在白色方块中间添加一个小的蓝色块。 我们当然可以简单地在已经存在的UIView上添加一个子视图（随意用代码或者IB），但这不能真正学到任何关于图层的东西。 于是我们来创建一个CALayer，并且把它作为我们视图相关图层的子图层。尽管UIView类的接口中暴露了图层属性，但是标准的Xcode项目模板并没有包含Core Animation相关头文件。所以如果我们不给项目添加合适的库，是不能够使用任何图层相关的方法或者访问它的属性。所以首先需要添加QuartzCore框架到Build Phases标签（图1.4），然后在vc的.m文件中引入库。 图1.4 把QuartzCore库添加到项目 之后就可以在代码中直接引用CALayer的属性和方法。在清单1.1中，我们用创建了一个CALayer，设置了它的backgroundColor属性，然后添加到layerView背后相关图层的子图层（这段代码的前提是通过IB创建了layerView并做好了连接），图1.5显示了结果。 清单1.1 给视图添加一个蓝色子图层 #import &quot;ViewController.h&quot; #import &lt;QuartzCore/QuartzCore.h&gt; @interface ViewController () @property (nonatomic, weak) IBOutlet UIView *layerView; ￼ @end @implementation ViewController - (void)viewDidLoad { [super viewDidLoad]; //create sublayer CALayer *blueLayer = [CALayer layer]; blueLayer.frame = CGRectMake(50.0f, 50.0f, 100.0f, 100.0f); blueLayer.backgroundColor = [UIColor blueColor].CGColor; //add it to our view [self.layerView.layer addSublayer:blueLayer]; } @end 图1.5 白色UIView内部嵌套的蓝色CALayer 一个视图只有一个相关联的图层（自动创建），同时它也可以支持添加无数多个子图层，从清单1.1可以看出，你可以显示创建一个单独的图层，并且把它直接添加到视图关联图层的子图层。尽管可以这样添加图层，但往往我们只是见简单地处理视图，他们关联的图层并不需要额外地手动添加子图层。 在Mac OS平台，10.8版本之前，一个显著的性能缺陷就是由于用了视图层级而不是单独在一个视图内使用CALayer树状层级。但是在iOS平台，使用轻量级的UIView类并没有显著的性能影响（当然在Mac OS 10.8之后，NSView的性能同样也得到很大程度的提高）。 使用图层关联的视图而不是CALayer的好处在于，你能在使用所有CALayer底层特性的同时，也可以使用UIView的高级API（比如自动排版，布局和事件处理）。 然而，当满足以下条件的时候，你可能更需要使用CALayer而不是UIView 开发同时可以在Mac OS上运行的跨平台应用 使用多种CALayer的子类（见第六章，“特殊的图层“），并且不想创建额外的UIView去包封装它们所有 做一些对性能特别挑剔的工作，比如对UIView一些可忽略不计的操作都会引起显著的不同（尽管在这种情况下，你可能会想直接使用OpenGL来绘图） 但是这些例子都很少见，总的来说，处理视图会比单独处理图层更加方便。 总结这一章阐述了图层的树状结构，说明了如何在iOS中由UIView的层级关系形成的一种平行的CALayer层级关系，在后面的实验中，我们创建了自己的CALayer，并把它添加到图层树中。 在第二章，“图层关联的图片”，我们将要研究一下CALayer关联的图片，以及Core Animation提供的操作显示的一些特性。","categories":[],"tags":[{"name":"iOS、图层","slug":"iOS、图层","permalink":"http://zhulele90.cn/tags/iOS、图层/"}]},{"title":"Image Processing in iOS","slug":"iOS-Image-Processing-in-iOS","date":"2017-06-06T07:26:40.000Z","updated":"2017-06-06T09:47:56.000Z","comments":true,"path":"2017/06/06/iOS-Image-Processing-in-iOS/","link":"","permalink":"http://zhulele90.cn/2017/06/06/iOS-Image-Processing-in-iOS/","excerpt":"图形图像的基础知识, 位图图像原图的修改","text":"图形图像的基础知识, 位图图像原图的修改 Image Processing in iOS基础知识 什么是图形图像? 一张图像就是像素点的集合，每一个像素都是一个单独明了的颜色.图像一般情况下都存储成数组，你可以把他们相像成2维数组。 如何用字节来表示颜色 表示颜色的方式有许多种: 最简单的32位RGBA模式 – 32位RGBA模式会将一个颜色值存储在32位，或者4个字节中。每一个字节存储一个部分或者一个颜色通道.可以表示接近17亿的颜色 颜色空间 RGB模式表示颜色是颜色空间的一个例子。它只是众多存储颜色方法中的一种。 灰阶空间。像它的名字一样，所有的图形都只有黑和白，只需要保存一个值来表示这种颜色 HSV，使用色调，饱和度和亮度来直观的存储颜色值。你可以把这三个部分这样来看: 色调就是颜色 饱和度就是这个颜色有多么的饱满 值就是颜色的亮度有多亮 YUV是另外一种常见的颜色空间，电视机使用的就是这种方式 坐标系统 UIImage和UIView使用的是左上原点坐标，Core Image和Core Graphics使用的是左下原点坐标。 图形压缩 如果你使用一张8像素的图形做运算，它将会消耗810^6像素4比特/像素=32兆字节内存. 这就是为什么会出现jpeg,png和其它图形格式的原因。这些都是图形压缩格式。 四个流行的图形图像处理方法位图图像原图修改 定义一个方法 修改图片 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495- (UIImage *)processUsingPixels:(UIImage*)inputImage&#123; // 1.把UIImage对象转换为需要被核心图形库调用的CGImage对象。同时，得到图形的宽度和高度。 CGImageRef inputCGImage = [inputImage CGImage]; NSUInteger inputWidth = CGImageGetWidth(inputCGImage); NSUInteger inputHeight = CGImageGetHeight(inputCGImage); // 2.由于你使用的是32位RGB颜色空间模式，你需要定义一些参数bytesPerPixel（每像素大小）和bitsPerComponent（每个颜色通道大小），然后计算图像bytesPerRow（每行有大）。最后，使用一个数组来存储像素的值。 UInt32 * inputPixels; NSUInteger bytesPerPixel = 4; NSUInteger bitsPerComponent = 8; NSUInteger inputBytesPerRow = bytesPerPixel * inputWidth; inputPixels = (UInt32 *)calloc(inputHeight * inputWidth, sizeof(UInt32)); // 3.创建一个RGB模式的颜色空间CGColorSpace和一个容器CGBitmapContext,将像素指针参数传递到容器中缓存进行存储。在后面的章节中将会进一步研究核图形库。 CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB(); CGContextRef context = CGBitmapContextCreate(inputPixels, inputWidth, inputHeight, bitsPerComponent, inputBytesPerRow, colorSpace, kCGImageAlphaPremultipliedLast | kCGBitmapByteOrder32Big); // 4.把缓存中的图形绘制到显示器上。像素的填充格式是由你在创建context的时候进行指定的 CGContextDrawImage(context, CGRectMake(0, 0, inputWidth, inputHeight), inputCGImage); // 5.创建一个幽灵的CGImageRef对象 UIImage * ghostImage = [UIImage imageNamed:@&quot;ghost&quot;]; CGImageRef ghostCGImage = [ghostImage CGImage]; // 6.把幽灵的图像宽度缩小25%，并把它的原点设定在点ghostOrigin CGFloat ghostImageAspectRatio = ghostImage.size.width / ghostImage.size.height; NSInteger targetGhostWidth = inputWidth * 0.25; CGSize ghostSize = CGSizeMake(targetGhostWidth, targetGhostWidth / ghostImageAspectRatio); CGPoint ghostOrigin = CGPointMake(inputWidth * 0.5, inputHeight * 0.2); // 7.创建一张幽灵图像的缓存图 NSUInteger ghostBytesPerRow = bytesPerPixel * ghostSize.width; UInt32 * ghostPixels = (UInt32 *)calloc(ghostSize.width * ghostSize.height, sizeof(UInt32)); CGContextRef ghostContext = CGBitmapContextCreate(ghostPixels, ghostSize.width, ghostSize.height, bitsPerComponent, ghostBytesPerRow, colorSpace, kCGImageAlphaPremultipliedLast | kCGBitmapByteOrder32Big); CGContextDrawImage(ghostContext, CGRectMake(0, 0, ghostSize.width, ghostSize.height),ghostCGImage); // 8.如同其它位图运算一样，你需要一些循环来遍历每一个像素 NSUInteger offsetPixelCountForInput = ghostOrigin.y * inputWidth + ghostOrigin.x; for (NSUInteger j = 0; j &lt; ghostSize.height; j++) &#123; for (NSUInteger i = 0; i &lt; ghostSize.width; i++) &#123; UInt32 *inputPixel = inputPixels + j * inputWidth + i + offsetPixelCountForInput; UInt32 inputColor = *inputPixel; UInt32 * ghostPixel5 = ghostPixels + j * (int)ghostSize.width + i; UInt32 ghostColor = *ghostPixel5; // 你将幽灵图像的每一个像素的透明通道都乘以了0.5，使它成为半透明状态。然后将它混合到图像中像之前讨论的那样 CGFloat ghostAlpha = 0.5f * (A(ghostColor) / 255.0); UInt32 newR = R(inputColor) * (1 - ghostAlpha) + R(ghostColor) * ghostAlpha; UInt32 newG = G(inputColor) * (1 - ghostAlpha) + G(ghostColor) * ghostAlpha; UInt32 newB = B(inputColor) * (1 - ghostAlpha) + B(ghostColor) * ghostAlpha; //clamping部分将每个颜色的值范围进行限定到0到255之间，虽然一般情况下值不会越界。但是，大多数情况下需要进行这种限定防止发生意外的错误输出 newR = MAX(0,MIN(255, newR)); newG = MAX(0,MIN(255, newG)); newB = MAX(0,MIN(255, newB)); *inputPixel = RGBAMake(newR, newG, newB, A(inputColor)); &#125; &#125; // 9.把每一个像素的红色，绿色，蓝色通道的值设定成三个通道原始颜色值的平均值 变成黑白颜色 for (NSUInteger j = 0; j &lt; inputHeight; j++) &#123; for (NSUInteger i = 0; i &lt; inputWidth; i++) &#123; UInt32 * currentPixel = inputPixels + (j * inputWidth) + i; UInt32 color = *currentPixel; // Average of RGB = greyscale UInt32 averageColor = (R(color) + G(color) + B(color)) / 3.0; *currentPixel = RGBAMake(averageColor, averageColor, averageColor, A(color)); &#125; &#125; // 10.创建一个新的图片 CGImageRef newCGImage = CGBitmapContextCreateImage(context); UIImage * processedImage = [UIImage imageWithCGImage:newCGImage]; // 11.清除内存。ARC不能代替你对CGImageRefs和CGContexts进行管理 CGColorSpaceRelease(colorSpace); CGContextRelease(context); CGContextRelease(ghostContext); free(inputPixels); free(ghostPixels); // 12.返回处理好的图片 return processedImage; &#125; 最后的效果图: 使用Core Graphics库 直接上代码: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556- (UIImage *)processUsingCoreGraphics:(UIImage*)input &#123; CGRect imageRect = &#123;CGPointZero,input.size&#125;; NSInteger inputWidth = CGRectGetWidth(imageRect); NSInteger inputHeight = CGRectGetHeight(imageRect); // 1. 添加ghost图片并且计算Ghosty的位置 UIImage * ghostImage = [UIImage imageNamed:@&quot;ghost.png&quot;]; CGFloat ghostImageAspectRatio = ghostImage.size.width / ghostImage.size.height; NSInteger targetGhostWidth = inputWidth * 0.25; CGSize ghostSize = CGSizeMake(targetGhostWidth, targetGhostWidth / ghostImageAspectRatio); CGPoint ghostOrigin = CGPointMake(inputWidth * 0.5, inputHeight * 0.2); CGRect ghostRect = &#123;ghostOrigin, ghostSize&#125;; UIGraphicsBeginImageContext(input.size); CGContextRef context = UIGraphicsGetCurrentContext(); // 把你的图像绘制到context中 CGAffineTransform flip = CGAffineTransformMakeScale(1.0, -1.0); CGAffineTransform flipThenShift = CGAffineTransformTranslate(flip,0,-inputHeight); CGContextConcatCTM(context, flipThenShift); // 1.1 将图片写入新的context里面 CGContextDrawImage(context, imageRect, [input CGImage]); // 1.2 设置alpha值为0.5，这只会影响后面的图像。 混合模式设置为kCGBlendModeSourceAtop. 然后翻转幽灵的坐标把它绘制在图像中. CGContextSetBlendMode(context, kCGBlendModeSourceAtop); CGContextSetAlpha(context,0.5); CGRect transformedGhostRect = CGRectApplyAffineTransform(ghostRect, flipThenShift); CGContextDrawImage(context, transformedGhostRect, [ghostImage CGImage]); // 1.3 取回处理的图像 UIImage * imageWithGhost = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); // 2. 绘制你的图像到一个灰度（grayscale）context中 // 2.1 创建一个带灰度的context CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceGray(); context = CGBitmapContextCreate(nil, inputWidth, inputHeight, 8, 0, colorSpace, (CGBitmapInfo)kCGImageAlphaNone); // 2.2 绘制图像进入context中 CGContextDrawImage(context, imageRect, [imageWithGhost CGImage]); // 2.3 取回处理后的图像 CGImageRef imageRef = CGBitmapContextCreateImage(context); UIImage * finalImage = [UIImage imageWithCGImage:imageRef]; // 清除缓存 CGColorSpaceRelease(colorSpace); CGContextRelease(context); CFRelease(imageRef); return finalImage;&#125; 内存使用：当执行图像处理时，密切关注内存使用情况。像在第一节中讨论的一样，一个8M像素的图像占用了高达32M的内存。尽量避免在内存中同一时间保持同一图像的多个复制。 注意到为什么我们第二次需要释放context而第一次不需要了吗？这是因为第一次时，你使用UIGraphicsGetCurrentImageContext()获取了context。这里的关键词是‘get’。‘Get’意味着你获取了当前context的引用，你并不持有它。 在第二次中，你调用了CGBitmapContextCreateImage()，Create意味着你持有这个对象，并需要管理它的生命周期。这也是你为什么需要释放imageRef的原因，因为你是通过CGBitmapContextCreateImage()创建它的。 使用Core Image库 Core Image是Apple的图像处理的解决方案。它避免了所有底层的像素操作方法，转而使用高级别的滤镜替代了它们。 Core Image最好的部分在于它对比操作原始像素或Core Graphics有着极好的性能。这个库使用CPU和GPU混合处理提供接近实时的性能。 Apple还提供了巨大的预先制作的滤镜库 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#import &quot;UIImage+OrientationFix.h&quot;- (UIImage *)processUsingCoreImage:(UIImage*)input &#123; CIImage * inputCIImage = [[CIImage alloc] initWithImage:input]; // 1.创建CIColorControls滤镜，设置它的inputSaturation值为0。你可能记得，饱和度是HSV颜色空间的一个通道。这里的0表示了灰度。 CIFilter * grayFilter = [CIFilter filterWithName:@&quot;CIColorControls&quot;]; [grayFilter setValue:@(0) forKeyPath:@&quot;inputSaturation&quot;]; // 2. 创建一个和输入图像一样大小的填充的幽灵图像 // Cheat: create a larger ghost image UIImage * ghostImage = [self createPaddedGhostImageWithSize:input.size]; CIImage * ghostCIImage = [[CIImage alloc] initWithImage:ghostImage]; // 3.创建CIColorMatrix滤镜，设置它的alphaVector值为[0 0 0.5 0]。这将给幽灵的alpha值增加0.5。 CIFilter * alphaFilter = [CIFilter filterWithName:@&quot;CIColorMatrix&quot;]; CIVector * alphaVector = [CIVector vectorWithX:0 Y:0 Z:0.5 W:0]; [alphaFilter setValue:alphaVector forKeyPath:@&quot;inputAVector&quot;]; // 4.创建CISourceAtopCompositing滤镜来进行alpha混合 CIFilter * blendFilter = [CIFilter filterWithName:@&quot;CISourceAtopCompositing&quot;]; // 5. 合并你的滤镜来处理图像 [alphaFilter setValue:ghostCIImage forKeyPath:@&quot;inputImage&quot;]; ghostCIImage = [alphaFilter outputImage]; [blendFilter setValue:ghostCIImage forKeyPath:@&quot;inputImage&quot;]; [blendFilter setValue:inputCIImage forKeyPath:@&quot;inputBackgroundImage&quot;]; CIImage * blendOutput = [blendFilter outputImage]; [grayFilter setValue:blendOutput forKeyPath:@&quot;inputImage&quot;]; CIImage * outputCIImage = [grayFilter outputImage]; // 6. 渲染输出CIImage到CGImage，创建最终的UIImage CIContext * context = [CIContext contextWithOptions:nil]; CGImageRef outputCGImage = [context createCGImage:outputCIImage fromRect:[outputCIImage extent]]; UIImage * outputImage = [UIImage imageWithCGImage:outputCGImage]; // 7. 释放内存 CGImageRelease(outputCGImage); return outputImage;&#125;// 使用Core Image，你设置了大量的滤镜来处理你的图像 – 你使用了CIColorControls滤镜来设置灰度，CIColorMatrix和CISourceAtopCompositing来设置混合，最后把它们连接在一起。 // 这个方法使用了一个叫做-createPaddedGhostImageWithSize:的帮助函数，它使用Core Graphics创建了输入图像25%大小缩小版的填充的幽灵。- (UIImage *)createPaddedGhostImageWithSize:(CGSize)inputSize &#123; UIImage * ghostImage = [UIImage imageNamed:@&quot;ghost.png&quot;]; CGFloat ghostImageAspectRatio = ghostImage.size.width / ghostImage.size.height; NSInteger targetGhostWidth = inputSize.width * 0.25; CGSize ghostSize = CGSizeMake(targetGhostWidth, targetGhostWidth / ghostImageAspectRatio); CGPoint ghostOrigin = CGPointMake(inputSize.width * 0.5, inputSize.height * 0.2); CGRect ghostRect = &#123;ghostOrigin, ghostSize&#125;; UIGraphicsBeginImageContext(inputSize); CGContextRef context = UIGraphicsGetCurrentContext(); CGRect inputRect = &#123;CGPointZero, inputSize&#125;; CGContextClearRect(context, inputRect); CGAffineTransform flip = CGAffineTransformMakeScale(1.0, -1.0); CGAffineTransform flipThenShift = CGAffineTransformTranslate(flip,0,-inputSize.height); CGContextConcatCTM(context, flipThenShift); CGRect transformedGhostRect = CGRectApplyAffineTransform(ghostRect, flipThenShift); CGContextDrawImage(context, transformedGhostRect, [ghostImage CGImage]); UIImage * paddedGhost = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return paddedGhost;&#125; GPUImage版本 GPUImage隐藏了在iOS中所有需要使用OpenGL ES的复杂的代码，并用极其简单的接口以很快的速度处理图像。 12345678910111213141516171819202122232425262728- (UIImage *)processUsingGPUImage:(UIImage*)input &#123; // 1. Create our GPUImagePictures GPUImagePicture * inputGPUImage = [[GPUImagePicture alloc] initWithImage:input]; UIImage * ghostImage = [self createPaddedGhostImageWithSize:input.size]; GPUImagePicture * ghostGPUImage = [[GPUImagePicture alloc] initWithImage:ghostImage]; // 2. Setup our filter chain GPUImageAlphaBlendFilter * alphaBlendFilter = [[GPUImageAlphaBlendFilter alloc] init]; alphaBlendFilter.mix = 0.5; [inputGPUImage addTarget:alphaBlendFilter atTextureLocation:0]; [ghostGPUImage addTarget:alphaBlendFilter atTextureLocation:1]; GPUImageGrayscaleFilter * grayscaleFilter = [[GPUImageGrayscaleFilter alloc] init]; [alphaBlendFilter addTarget:grayscaleFilter]; // 3. Process &amp; grab output image [inputGPUImage processImage]; [ghostGPUImage processImage]; [grayscaleFilter useNextFrameForImageCapture]; UIImage * output = [grayscaleFilter imageFromCurrentFramebuffer]; return output;&#125; 1.创建GPUImagePicture对象；再次使用-createPaddedGhostImageWithSize:为一个工具。这时GPUImage会把图像纹理上传到GPU内存。 2.创建和链接你将要使用的滤镜。这种链接与Core Image中的滤镜链接不同，它类似于管道。在你完成后，它看起来是这样的： 3.GPUImageAlphaBlendFilter接受两个输入，在这种情况下为顶部和底部的图像，纹理的位置很重要。-addTarget:atTextureLocation: 设置纹理为正确的输入（位置）。 4.在链中的最后一个滤镜调用-useNextFrameForImageCapture然后对两个输入调用-processImage 。这可以确保滤镜知道你想要从中抓取图像然后持有它。","categories":[],"tags":[]},{"title":"DOM第一讲","slug":"DOM第一讲","date":"2017-05-24T01:55:47.000Z","updated":"2017-05-24T03:51:35.000Z","comments":true,"path":"2017/05/24/DOM第一讲/","link":"","permalink":"http://zhulele90.cn/2017/05/24/DOM第一讲/","excerpt":"DOM就是HTML文档的模型抽象, 数据以树的形式在内存中排列。","text":"DOM就是HTML文档的模型抽象, 数据以树的形式在内存中排列。 DOM事件 事件三要素 获取事件源： document.getElementById(“box”) document.getElementsByTagName(“div”) 获取的是数组 document.getElementsByName(“aaa”) 获取的是数组 H5之后 绑定事件：事件源.事件 = function(){ 事件驱动程序 }: 匿名绑定 box.onclick = function(){ 程序 }; 函数名绑定 box.onclick = fn; function fn(){ 程序 }; 行内绑定 div id=”box” onclick=”fn()”&gt;&lt;/div; function fn(){ 程序 }; 书写事件驱动程序：关于DOM的操作, 可以操作标签的属性和样式。 事件有哪些 注意: js的加载时和html同步加载的。（如果使用元素在定义元素之间，容易报错）整个页面上所有元素加载完毕再执行js内容，window.onload可以预防使用标签在定义标签之前。 DOM概述","categories":[],"tags":[]},{"title":"冒泡排序","slug":"冒泡排序","date":"2017-05-22T02:35:32.000Z","updated":"2017-05-22T02:47:06.000Z","comments":true,"path":"2017/05/22/冒泡排序/","link":"","permalink":"http://zhulele90.cn/2017/05/22/冒泡排序/","excerpt":"三种冒泡排序的方法","text":"三种冒泡排序的方法 冒泡排序简单版 需求：冒泡排序。 理论：1.比较轮数n-1。 2.比较次数n-1。 3.符合某个条件交换位置。 核心：双重for循环。 步骤： 1.双重for循环。 2.指定轮数和次数 3.判断是否符合标准。如果符合标准交换位置。 12345678910111213141516 var arr = [7,6,5,4,3,2,1];//1.双重for循环。(外循环控制轮数) for(var i=0;i&lt;arr.length-1;i++)&#123; //2.指定轮数和次数（内循环控制次数） for(var j=0;j&lt;arr.length-1;j++)&#123; //3.判断是否符合标准。如果符合标准交换位置。 //从小到大排列顺滑，如果前面的比后面的大，那么交换位置。 if(arr[j] &gt; arr[j+1])&#123; var temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; &#125; &#125; &#125; console.log(arr); 进阶版 每轮比较少比较一次。（每一轮都会比较出一个最大值，然后后一轮没有必要再比较了，所以没比较一轮，就少比较一次。。。） 123456789101112131415161718192021var arr = [7,6,5,4,3,2,1];var m = 0; var n = 0; //1.双重for循环。(外循环控制轮数) for(var i=0;i&lt;arr.length-1;i++)&#123; //2.指定轮数和次数（内循环控制次数） for(var j=0;j&lt;arr.length-1-i;j++)&#123; //3.判断是否符合标准。如果符合标准交换位置。 //从小到大排列顺滑，如果前面的比后面的大，那么交换位置。 if(arr[j] &gt; arr[j+1])&#123; var temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; &#125; m++; &#125; n++; &#125; console.log(arr); console.log(m); console.log(n); 高级版 如果比较完备提前结束比较。（判断，如果本次比较没有移动任何元素，那么说明已经比较完成） 1234567891011121314151617181920212223242526272829var arr = [7,6,5,4,3,2,1];var m = 0; var n = 0; //1.双重for循环。(外循环控制轮数) for(var i=0;i&lt;arr.length-1;i++)&#123; //开闭原则。（写在第一个for循环里，是为了，每轮比较初始化bool变量变为true。） var bool = true; //2.指定轮数和次数（内循环控制次数） for(var j=0;j&lt;arr.length-1-i;j++)&#123; //3.判断是否符合标准。如果符合标准交换位置。 //从小到大排列顺滑，如果前面的比后面的大，那么交换位置。 if(arr[j] &gt; arr[j+1])&#123; var temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; bool = false; &#125; m++; &#125; n++; //bool这个变量默认值为true;如果本轮比较有一对元素相互交换位置，那么也不能跳出循环。 //但是，如果本轮比较没有任何元素相互交换位置，那么说明已经比较完成，可以跳出循环。 if(bool)&#123; break; &#125; &#125; console.log(arr); console.log(m); console.log(n);","categories":[],"tags":[{"name":"冒泡","slug":"冒泡","permalink":"http://zhulele90.cn/tags/冒泡/"}]},{"title":"js第二天","slug":"js第二天","date":"2017-05-16T09:36:49.000Z","updated":"2017-05-17T02:26:06.000Z","comments":true,"path":"2017/05/16/js第二天/","link":"","permalink":"http://zhulele90.cn/2017/05/16/js第二天/","excerpt":"Javascript 书写位置 变量等基础知识","text":"Javascript 书写位置 变量等基础知识 JavaScript 基础02书写位置基本代码: 分号不能省略 123&lt;script type=\"text/javascript\"&gt; &lt;/script&gt; 位置: 内嵌式: 可以放在任意位置, 因为html的编译顺序, 最好放在下面位置: 1234&lt;/body&gt;&lt;/html&gt;&lt;script type=\"text/javascript\"&gt;&lt;/script&gt; 外链式: 1&lt;script src=\"1.js\"&gt;&lt;/script&gt; 将多个JS文件合并成一个文件 输出消息的几种方式 alert comfirm 弹出框 console.log 控制台日志 prompt 接收用户输入信息 document.write 在页面输出信息 可以输出标签 变量变量是用来存储数据的容器 变量的命名规范 不能以数字或者纯数字开头来定义变量名 不推荐使用中文来定义变量名 不能使用特殊符号或者特殊符号开头(-除外) 不推荐使用关键字和保留字来定义变量名 在JS中严格区分大小写的！！！ 数据类型1. 简单数据类型 Number 数字类型 包含正数 负数 小数 字符串 String 凡是用双引号或者单引号引起的都是字符串。 布尔数据类型 Boolean 只有2个值一个是true, 一个是false. 实际运算中true=1,false=0 undefined 变量未初始化 定义了变量，没有给变量赋值 null 变量未引用 值为空 内存中没有 object 2. 复杂数据类型 object 对象 array 数组 3. 判断数据类型typeof() 运算符 比较运算符&lt; &gt; &lt;= &gt;= == != 算术运算符 “+” 加号 两个数字类型的变量相加，得到的是一个数字类型。 一个数字类型和一个字符串相加，得到的是一个字符串。 “—“ 减号 两个数字类型的变量相减，得到的是一个数字类型。 一个数字类型和一个数字字符串相减，得到的是一个数字类型。 一个数字类型和一个非数字字符串相减，得到的是NaN(not a number),是一个数字类型。 “/“ 除号 两个数字类型的变量相除，得到的是一个数字类型。 一个数字类型和一个数字字符串相除，得到的是一个数字类型。 一个数字类型和一个非数字字符串相除，得到的是NaN,是一个数字类型。 0做为除数的时候，得到结果 Infinity （无限大），是一个数字类型。 “%” 取余数 优先级 有()先计算()里边的 Date对象Date对象用于处理日期和时间 12345678910&lt;script type=\"text/javascript\"&gt; var mydate=new Date();//通过new方法创建对象 alert(Date()); // 返回一个完整的日期时间 alert(mydate.getDay());//返回当前是周几 alert(mydate.getMonth()+1);//返回当前月份 alert(mydate.getFullYear());//返回当前年份 alert(mydate.getHours());//返回当前小时 alert(mydate.getMinutes());//返回当前分钟 alert(mydate.getSeconds());//返回当前秒数&lt;/script&gt; Math对象对象123456789101112131415&lt;script type=\"text/javascript\"&gt; var n1=12; var n2=1.23; var n3=3.98; var n4=-12.01; var n5=Math.ceil(n4); //天花板函数 向上去整 var n5=Math.floor(n4); // 向下舍入 var n5=Math.max(n1,n4); //取的是两个数的最大值 var n5=Math.min(n3,n1); //返回是两个数的最小值 var n5=Math.pow(n1,n2); //返回n1的n2次方 var n5=Math.round(n4); // 进行四舍五入操作 var n5=Math.random(); //返回0-1之间的随机数 不包括0和1 alert(n5);&lt;/script&gt; 数据类型转换12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;script type=\"text/javascript\"&gt;var n1=1; var n2=23.45; var n3=-34.1; // 数字转字符串 三种方法 var n1=String(n1);// 数字转字符串 var n5=n2.toString();// 变量转字符串 alert(n5); alert(typeof(n5)); var n1=\"123\"; var n2=\"12abc\"; var n3=\"mylove\"; var n4=\"14期威武\"; var n6=\"-5.93\"; // 字符串转数字 三种方法 /* Number() 1.数字类型的字符串，转换之后得到的数字 2.非数字字符串，转换之后得到是NaN 3.小数类型的字符串，转换之后得到的是原数字 */ var n5=Number(n1); /* parseInt() 1.整数数字类型的字符串，转换之后得到的整数数字。 2.数字开头的字符串，转换之后得到的是前边的数字。 3.非数字开头的字符串，转换之后得到的是NaN。 4.小数类型的字符串，转换之后取整。 */ var n5=parseInt(n1); /* parseFloat() 1.整数数字类型的字符串，转换之后得到的整数数字。 2.数字开头的字符串，转换之后得到的是前边的数字。 3.非数字开头的字符串，转换之后得到的是NaN。 4.小数类型的字符串，转换之后得到的是原数字。 */ var n5=parseFloat(n6); alert(n5); alert(typeof(n5)); var n1=123; var n2=\"345\"; var n3; var n4=null; var n6=0; var n7=Infinity; // 转布尔类型 var n5=Boolean(n7); /* 1.数字和字符串转完之后为true。 2.undefined、null、0转完之后为false. */ alert(n5); alert(typeof(n5)); // 隐式数据类型转换 var n1=12; var n2=\"3\"; var n3=n1-n2; alert(n2); alert(typeof(n2));&lt;/script&gt; 运算符 逻辑运算符 且&amp;&amp; 两个表达式为true的时候，结果为true 或|| 只要有一个表达式为true,结果为true 非！ 和表达式相反的结果 等号运算符 “=”赋值运算符 “==”只判断内容是否相同，不判断数据类型。 “===”不仅判断内容，还判断数据类型是否相同。 ！= 只判断内容是否不相同，不判断数据类型。 ！==不全等于 不仅判断内容是否不相同，还判断数据类型是否不相同。 变量的集体声明1var n1=1,n2=2,n3=3;n1+=n2;//变量的集体声明 几种语句 switch语句 123456789101112131415161718192021222324252627var fruit=prompt(\"请输入您喜欢吃的水果\");// switch后边的变量和case后边值的数据类型必须保持一致 switch(fruit)&#123; case \"苹果\": alert(\"您喜欢吃的是苹果\"); break; //阻断代码执行 case \"香蕉\": alert(\"您喜欢吃的是香蕉\"); break; case \"葡萄\": alert(\"您喜欢吃的是葡萄\"); break; default: alert(\"口味真重\"); break; &#125; // 可以对变量进行集体判断 switch(fruit)&#123; case \"苹果\": case \"香蕉\": case \"葡萄\":// case值的集体声明 alert(\"您喜欢吃水果\"); break; default: alert(\"口味真重\"); break; &#125; 自增自减 i++ ++i –i i– 1234567891011var n1=123;// 在不参与运算的情况下，i++和++i都是在变量的基础加1n1++; //==&gt;n1=n1+1; 在变量原来的基础上加1++n1; //==&gt;n1=n1+1; 在变量原来的基础上加1alert(n1);// 在参与运算的情况下var n1=123;var n2=n1++; //先将n1赋值给n2，之后n1再自增var n2=++n1; //n1先自增，在赋值给n2alert(n2);alert(n1); 数组12345678910111213141516171819202122232425262728293031&lt;script type=\"text/javascript\"&gt; // 数组的定义 var ary1=new Array(); //用new方法来创建一个数组 var ary1=[]; //直接创建一个数组 ary1[0]=12; //通过下标给数组赋值 ary1[1]=23; ary1[2]=\"中国人\"; ary1[3]=\"美国人\"; alert(ary1); //显示数组 //数组的初始化 var ary1=[12,23,45,\"中国人\",\"34\"]; alert(ary1); // 数组的遍历 for(var i=0; i&lt;5; i++)&#123; alert(ary1[i]); &#125; // length属性代表数组数据的个数 var ary=[1,\"2k\",\"e3\",43,23,23,54,65,\"y5\",\"y6\",7]; for(var i=0;i&lt;ary.length; i++)&#123; alert(ary[i]); &#125; var ary1=[2,23,32,21,345,46]; var ary2=[2,3,4,8,12,\"来两串\"]; // 数组的合并 var ary3=ary1.concat(ary2); // 返回一个数组 alert(ary3); var ary1=[2,23,32,21,345,46,\"中国人\"]; var ary2=ary1.join(\"&amp;\"); // 返回一个字符串 alert(ary2); alert(typeof(ary2)); &lt;/script&gt; 函数1234function test()&#123; //通过function创建函数 alert(\"乐乐牛\"); &#125; test(); //函数调用","categories":[],"tags":[{"name":"1","slug":"1","permalink":"http://zhulele90.cn/tags/1/"}]},{"title":"js第一天","slug":"js第一天","date":"2017-05-15T14:54:13.000Z","updated":"2017-05-17T02:26:50.000Z","comments":true,"path":"2017/05/15/js第一天/","link":"","permalink":"http://zhulele90.cn/2017/05/15/js第一天/","excerpt":"Javascript 历史 特点等基础知识","text":"Javascript 历史 特点等基础知识 JavaScript基础(Day1)JavaScript历史34岁的系统程序员Brendan Eich（布兰登·艾奇）, 1995年4月, 网景公司录用了他, 1995年5月他只用10天时间就把Javascript设计出来. 1995.2月 Netscape公司发布LiveScript，后临时改为JavaScript，为了赶上Java的热浪 1997 年，以JavaScript 1.1 为基础。由来自 Netscape、Sun、微软、Borland 和其他一些对脚本编程感兴趣的公司的程序员组成的 TC39（ECMA的小组） 锤炼出了 ECMA-262，也就是ECMAScript1.0。 1998年6月，ECMAScript 2.0版发布。 1999年12月，ECMAScript 3.0版发布，成为JavaScript的通行标准，得到了广泛支持. 2007年10月，ECMAScript 4.0版草案发布：分歧太大，失败告终。 2009年12月，ECMAScript 5.0版正式发布. 2015年6月17日，ECMAScript 6发布正式版本，即ECMAScript 2015。 认识JavaScriptJavaScript是一种网页编程技术, 就是一种基于对象和事件驱动，并具有安全性能的脚本语言,可以被嵌入到HTML文件中，不需要经过Web服务器就可以对用户操作作出响应. 组成 ECMAScript：JavaScript的语法标准。 DOM：JavaScript操作网页上的元素的API BOM：JavaScript操作浏览器的部分功能的API 特点 简单易用 可以使用任何文本编辑工具编写 只需要浏览器就可以执行程序 解释执行（解释语言） 事先不编译 逐行执行 无需进行严格的变量声明 基于对象 内置大量现成对象，编写少量程序可以完成目标","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://zhulele90.cn/tags/Javascript/"}]}]}