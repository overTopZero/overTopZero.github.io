{"meta":{"title":"Craco的博客","subtitle":"一个热爱编程的程序猿","description":"辽宁科技大学08级, 就职于上海宏驰, 擅长iOS, web前端, 非专业视觉设计师。此为博客一枚。","author":"Craco","url":"http://zhulele90.cn"},"pages":[],"posts":[{"title":"Image Processing in iOS","slug":"iOS-Image-Processing-in-iOS","date":"2017-06-06T07:26:40.000Z","updated":"2017-06-06T09:21:13.000Z","comments":true,"path":"2017/06/06/iOS-Image-Processing-in-iOS/","link":"","permalink":"http://zhulele90.cn/2017/06/06/iOS-Image-Processing-in-iOS/","excerpt":"图形图像的基础知识, 位图图像原图的修改","text":"图形图像的基础知识, 位图图像原图的修改 Image Processing in iOS基础知识 什么是图形图像? 一张图像就是像素点的集合，每一个像素都是一个单独明了的颜色.图像一般情况下都存储成数组，你可以把他们相像成2维数组。 如何用字节来表示颜色 表示颜色的方式有许多种: 最简单的32位RGBA模式 – 32位RGBA模式会将一个颜色值存储在32位，或者4个字节中。每一个字节存储一个部分或者一个颜色通道.可以表示接近17亿的颜色 颜色空间 RGB模式表示颜色是颜色空间的一个例子。它只是众多存储颜色方法中的一种。 灰阶空间。像它的名字一样，所有的图形都只有黑和白，只需要保存一个值来表示这种颜色 HSV，使用色调，饱和度和亮度来直观的存储颜色值。你可以把这三个部分这样来看: 色调就是颜色 饱和度就是这个颜色有多么的饱满 值就是颜色的亮度有多亮 YUV是另外一种常见的颜色空间，电视机使用的就是这种方式 坐标系统 UIImage和UIView使用的是左上原点坐标，Core Image和Core Graphics使用的是左下原点坐标。 图形压缩 如果你使用一张8像素的图形做运算，它将会消耗810^6像素4比特/像素=32兆字节内存. 这就是为什么会出现jpeg,png和其它图形格式的原因。这些都是图形压缩格式。 四个流行的图形图像处理方法位图图像原图修改 定义一个方法 修改图片 1- (UIImage *)processUsingPixels:(UIImage*)inputImage; 把UIImage对象转换为需要被核心图形库调用的CGImage对象。同时，得到图形的宽度和高度。 123CGImageRef inputCGImage = [inputImage CGImage];NSUInteger inputWidth = CGImageGetWidth(inputCGImage); NSUInteger inputHeight = CGImageGetHeight(inputCGImage); 由于你使用的是32位RGB颜色空间模式，你需要定义一些参数bytesPerPixel（每像素大小）和bitsPerComponent（每个颜色通道大小），然后计算图像bytesPerRow（每行有大）。最后，使用一个数组来存储像素的值。 1234567891011121314151617181920212223242526272829303132333435363738 UInt32 * inputPixels; NSUInteger bytesPerPixel = 4; NSUInteger bitsPerComponent = 8; NSUInteger inputBytesPerRow = bytesPerPixel * inputWidth; inputPixels = (UInt32 *)calloc(inputHeight * inputWidth, sizeof(UInt32));~~~ * 创建一个RGB模式的颜色空间CGColorSpace和一个容器CGBitmapContext,将像素指针参数传递到容器中缓存进行存储。在后面的章节中将会进一步研究核图形库。~~~objective-c CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB(); CGContextRef context = CGBitmapContextCreate(inputPixels, inputWidth, inputHeight, bitsPerComponent, inputBytesPerRow, colorSpace, kCGImageAlphaPremultipliedLast | kCGBitmapByteOrder32Big);~~~ * 把缓存中的图形绘制到显示器上。像素的填充格式是由你在创建context的时候进行指定的~~~objective-c CGContextDrawImage(context, CGRectMake(0, 0, inputWidth, inputHeight), inputCGImage);~~~ * 创建一个幽灵的CGImageRef对象~~~objective-c UIImage * ghostImage = [UIImage imageNamed:@&quot;ghost&quot;]; CGImageRef ghostCGImage = [ghostImage CGImage]; ~~~ * 把幽灵的图像宽度缩小25%，并把它的原点设定在点ghostOrigin~~~objective-cCGFloat ghostImageAspectRatio = ghostImage.size.width / ghostImage.size.height; NSInteger targetGhostWidth = inputWidth * 0.25; CGSize ghostSize = CGSizeMake(targetGhostWidth, targetGhostWidth / ghostImageAspectRatio); CGPoint ghostOrigin = CGPointMake(inputWidth * 0.5, inputHeight * 0.2); 创建一张幽灵图像的缓存图 123456789NSUInteger ghostBytesPerRow = bytesPerPixel * ghostSize.width; UInt32 * ghostPixels = (UInt32 *)calloc(ghostSize.width * ghostSize.height, sizeof(UInt32)); CGContextRef ghostContext = CGBitmapContextCreate(ghostPixels, ghostSize.width, ghostSize.height, bitsPerComponent, ghostBytesPerRow, colorSpace, kCGImageAlphaPremultipliedLast | kCGBitmapByteOrder32Big); CGContextDrawImage(ghostContext, CGRectMake(0, 0, ghostSize.width, ghostSize.height),ghostCGImage); 如同其它位图运算一样，你需要一些循环来遍历每一个像素 1234567891011121314151617181920212223NSUInteger offsetPixelCountForInput = ghostOrigin.y * inputWidth + ghostOrigin.x;for (NSUInteger j = 0; j &lt; ghostSize.height; j++) &#123; for (NSUInteger i = 0; i &lt; ghostSize.width; i++) &#123; UInt32 *inputPixel = inputPixels + j * inputWidth + i + offsetPixelCountForInput; UInt32 inputColor = *inputPixel; UInt32 * ghostPixel5 = ghostPixels + j * (int)ghostSize.width + i; UInt32 ghostColor = *ghostPixel5; // 你将幽灵图像的每一个像素的透明通道都乘以了0.5，使它成为半透明状态。然后将它混合到图像中像之前讨论的那样 CGFloat ghostAlpha = 0.5f * (A(ghostColor) / 255.0); UInt32 newR = R(inputColor) * (1 - ghostAlpha) + R(ghostColor) * ghostAlpha; UInt32 newG = G(inputColor) * (1 - ghostAlpha) + G(ghostColor) * ghostAlpha; UInt32 newB = B(inputColor) * (1 - ghostAlpha) + B(ghostColor) * ghostAlpha; //clamping部分将每个颜色的值范围进行限定到0到255之间，虽然一般情况下值不会越界。但是，大多数情况下需要进行这种限定防止发生意外的错误输出 newR = MAX(0,MIN(255, newR)); newG = MAX(0,MIN(255, newG)); newB = MAX(0,MIN(255, newB)); *inputPixel = RGBAMake(newR, newG, newB, A(inputColor)); &#125;&#125; 把每一个像素的红色，绿色，蓝色通道的值设定成三个通道原始颜色值的平均值 变成黑白颜色 1234567891011for (NSUInteger j = 0; j &lt; inputHeight; j++) &#123; for (NSUInteger i = 0; i &lt; inputWidth; i++) &#123; UInt32 * currentPixel = inputPixels + (j * inputWidth) + i; UInt32 color = *currentPixel; // Average of RGB = greyscale UInt32 averageColor = (R(color) + G(color) + B(color)) / 3.0; *currentPixel = RGBAMake(averageColor, averageColor, averageColor, A(color)); &#125;&#125; 创建一个新的图片 12CGImageRef newCGImage = CGBitmapContextCreateImage(context);UIImage * processedImage = [UIImage imageWithCGImage:newCGImage]; 清除内存。ARC不能代替你对CGImageRefs和CGContexts进行管理 1234567891011 CGColorSpaceRelease(colorSpace); CGContextRelease(context); CGContextRelease(ghostContext); free(inputPixels); free(ghostPixels);~~~ * 返回处理好的图片~~~objective-c return processedImage; 最后的效果图: 使用Core Graphics库直接上代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182- (UIImage *)processUsingCoreGraphics:(UIImage*)input &#123; CGRect imageRect = &#123;CGPointZero,input.size&#125;; NSInteger inputWidth = CGRectGetWidth(imageRect); NSInteger inputHeight = CGRectGetHeight(imageRect); // 1. 添加ghost图片并且计算Ghosty的位置 UIImage * ghostImage = [UIImage imageNamed:@&quot;ghost.png&quot;]; CGFloat ghostImageAspectRatio = ghostImage.size.width / ghostImage.size.height; NSInteger targetGhostWidth = inputWidth * 0.25; CGSize ghostSize = CGSizeMake(targetGhostWidth, targetGhostWidth / ghostImageAspectRatio); CGPoint ghostOrigin = CGPointMake(inputWidth * 0.5, inputHeight * 0.2); CGRect ghostRect = &#123;ghostOrigin, ghostSize&#125;; UIGraphicsBeginImageContext(input.size); CGContextRef context = UIGraphicsGetCurrentContext(); // 把你的图像绘制到context中 CGAffineTransform flip = CGAffineTransformMakeScale(1.0, -1.0); CGAffineTransform flipThenShift = CGAffineTransformTranslate(flip,0,-inputHeight); CGContextConcatCTM(context, flipThenShift); // 1.1 将图片写入新的context里面 CGContextDrawImage(context, imageRect, [input CGImage]); // 1.2 设置alpha值为0.5，这只会影响后面的图像。 混合模式设置为kCGBlendModeSourceAtop. 然后翻转幽灵的坐标把它绘制在图像中. CGContextSetBlendMode(context, kCGBlendModeSourceAtop); CGContextSetAlpha(context,0.5); CGRect transformedGhostRect = CGRectApplyAffineTransform(ghostRect, flipThenShift); CGContextDrawImage(context, transformedGhostRect, [ghostImage CGImage]); // 1.3 取回处理的图像 UIImage * imageWithGhost = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); // 2. 绘制你的图像到一个灰度（grayscale）context中 // 2.1 创建一个带灰度的context CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceGray(); context = CGBitmapContextCreate(nil, inputWidth, inputHeight, 8, 0, colorSpace, (CGBitmapInfo)kCGImageAlphaNone); // 2.2 绘制图像进入context中 CGContextDrawImage(context, imageRect, [imageWithGhost CGImage]); // 2.3 取回处理后的图像 CGImageRef imageRef = CGBitmapContextCreateImage(context); UIImage * finalImage = [UIImage imageWithCGImage:imageRef]; // 清除缓存 CGColorSpaceRelease(colorSpace); CGContextRelease(context); CFRelease(imageRef); return finalImage;&#125;~~~ &lt;font color=red face=&quot;黑体&quot;&gt;注意:&lt;/font&gt;* 内存使用：当执行图像处理时，密切关注内存使用情况。像在第一节中讨论的一样，一个8M像素的图像占用了高达32M的内存。尽量避免在内存中同一时间保持同一图像的多个复制。* 注意到为什么我们第二次需要释放context而第一次不需要了吗？这是因为第一次时，你使用UIGraphicsGetCurrentImageContext()获取了context。这里的关键词是‘get’。‘Get’意味着你获取了当前context的引用，你并不持有它。* 在第二次中，你调用了CGBitmapContextCreateImage()，Create意味着你持有这个对象，并需要管理它的生命周期。这也是你为什么需要释放imageRef的原因，因为你是通过CGBitmapContextCreateImage()创建它的。 #### 使用Core Image库* Core Image是Apple的图像处理的解决方案。它避免了所有底层的像素操作方法，转而使用高级别的滤镜替代了它们。* Core Image最好的部分在于它对比操作原始像素或Core Graphics有着极好的性能。这个库使用CPU和GPU混合处理提供接近实时的性能。* Apple还提供了巨大的预先制作的滤镜库~~~objective-c#import &quot;UIImage+OrientationFix.h&quot;- (UIImage *)processUsingCoreImage:(UIImage*)input &#123; CIImage * inputCIImage = [[CIImage alloc] initWithImage:input]; // 1.创建CIColorControls滤镜，设置它的inputSaturation值为0。你可能记得，饱和度是HSV颜色空间的一个通道。这里的0表示了灰度。 CIFilter * grayFilter = [CIFilter filterWithName:@&quot;CIColorControls&quot;]; [grayFilter setValue:@(0) forKeyPath:@&quot;inputSaturation&quot;]; // 2. 创建一个和输入图像一样大小的填充的幽灵图像 // Cheat: create a larger ghost image UIImage * ghostImage = [self createPaddedGhostImageWithSize:input.size]; CIImage * ghostCIImage = [[CIImage alloc] initWithImage:ghostImage]; // 3.创建CIColorMatrix滤镜，设置它的alphaVector值为[0 0 0.5 0]。这将给幽灵的alpha值增加0.5。 CIFilter * alphaFilter = [CIFilter filterWithName:@&quot;CIColorMatrix&quot;]; CIVector * alphaVector = [CIVector vectorWithX:0 Y:0 Z:0.5 W:0]; [alphaFilter setValue:alphaVector forKeyPath:@&quot;inputAVector&quot;]; // 4.创建CISourceAtopCompositing滤镜来进行alpha混合 CIFilter * blendFilter = [CIFilter filterWithName:@&quot;CISourceAtopCompositing&quot;]; // 5. 合并你的滤镜来处理图像 [alphaFilter setValue:ghostCIImage forKeyPath:@&quot;inputImage&quot;]; ghostCIImage = [alphaFilter outputImage]; [blendFilter setValue:ghostCIImage forKeyPath:@&quot;inputImage&quot;]; [blendFilter setValue:inputCIImage forKeyPath:@&quot;inputBackgroundImage&quot;]; CIImage * blendOutput = [blendFilter outputImage]; [grayFilter setValue:blendOutput forKeyPath:@&quot;inputImage&quot;]; CIImage * outputCIImage = [grayFilter outputImage]; // 6. 渲染输出CIImage到CGImage，创建最终的UIImage CIContext * context = [CIContext contextWithOptions:nil]; CGImageRef outputCGImage = [context createCGImage:outputCIImage fromRect:[outputCIImage extent]]; UIImage * outputImage = [UIImage imageWithCGImage:outputCGImage]; // 7. 释放内存 CGImageRelease(outputCGImage); return outputImage;&#125;// 使用Core Image，你设置了大量的滤镜来处理你的图像 – 你使用了CIColorControls滤镜来设置灰度，CIColorMatrix和CISourceAtopCompositing来设置混合，最后把它们连接在一起。 // 这个方法使用了一个叫做-createPaddedGhostImageWithSize:的帮助函数，它使用Core Graphics创建了输入图像25%大小缩小版的填充的幽灵。- (UIImage *)createPaddedGhostImageWithSize:(CGSize)inputSize &#123; UIImage * ghostImage = [UIImage imageNamed:@&quot;ghost.png&quot;]; CGFloat ghostImageAspectRatio = ghostImage.size.width / ghostImage.size.height; NSInteger targetGhostWidth = inputSize.width * 0.25; CGSize ghostSize = CGSizeMake(targetGhostWidth, targetGhostWidth / ghostImageAspectRatio); CGPoint ghostOrigin = CGPointMake(inputSize.width * 0.5, inputSize.height * 0.2); CGRect ghostRect = &#123;ghostOrigin, ghostSize&#125;; UIGraphicsBeginImageContext(inputSize); CGContextRef context = UIGraphicsGetCurrentContext(); CGRect inputRect = &#123;CGPointZero, inputSize&#125;; CGContextClearRect(context, inputRect); CGAffineTransform flip = CGAffineTransformMakeScale(1.0, -1.0); CGAffineTransform flipThenShift = CGAffineTransformTranslate(flip,0,-inputSize.height); CGContextConcatCTM(context, flipThenShift); CGRect transformedGhostRect = CGRectApplyAffineTransform(ghostRect, flipThenShift); CGContextDrawImage(context, transformedGhostRect, [ghostImage CGImage]); UIImage * paddedGhost = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return paddedGhost;&#125;~~~ #### GPUImage版本* GPUImage隐藏了在iOS中所有需要使用OpenGL ES的复杂的代码，并用极其简单的接口以很快的速度处理图像。 ~~~objective-c- (UIImage *)processUsingGPUImage:(UIImage*)input &#123; // 1. Create our GPUImagePictures GPUImagePicture * inputGPUImage = [[GPUImagePicture alloc] initWithImage:input]; UIImage * ghostImage = [self createPaddedGhostImageWithSize:input.size]; GPUImagePicture * ghostGPUImage = [[GPUImagePicture alloc] initWithImage:ghostImage]; // 2. Setup our filter chain GPUImageAlphaBlendFilter * alphaBlendFilter = [[GPUImageAlphaBlendFilter alloc] init]; alphaBlendFilter.mix = 0.5; [inputGPUImage addTarget:alphaBlendFilter atTextureLocation:0]; [ghostGPUImage addTarget:alphaBlendFilter atTextureLocation:1]; GPUImageGrayscaleFilter * grayscaleFilter = [[GPUImageGrayscaleFilter alloc] init]; [alphaBlendFilter addTarget:grayscaleFilter]; // 3. Process &amp; grab output image [inputGPUImage processImage]; [ghostGPUImage processImage]; [grayscaleFilter useNextFrameForImageCapture]; UIImage * output = [grayscaleFilter imageFromCurrentFramebuffer]; return output;&#125; 1.创建GPUImagePicture对象；再次使用-createPaddedGhostImageWithSize:为一个工具。这时GPUImage会把图像纹理上传到GPU内存。 2.创建和链接你将要使用的滤镜。这种链接与Core Image中的滤镜链接不同，它类似于管道。在你完成后，它看起来是这样的： 3.GPUImageAlphaBlendFilter接受两个输入，在这种情况下为顶部和底部的图像，纹理的位置很重要。-addTarget:atTextureLocation: 设置纹理为正确的输入（位置）。 4.在链中的最后一个滤镜调用-useNextFrameForImageCapture然后对两个输入调用-processImage 。这可以确保滤镜知道你想要从中抓取图像然后持有它。","categories":[],"tags":[]},{"title":"DOM第一讲","slug":"DOM第一讲","date":"2017-05-24T01:55:47.000Z","updated":"2017-05-24T03:51:35.000Z","comments":true,"path":"2017/05/24/DOM第一讲/","link":"","permalink":"http://zhulele90.cn/2017/05/24/DOM第一讲/","excerpt":"DOM就是HTML文档的模型抽象, 数据以树的形式在内存中排列。","text":"DOM就是HTML文档的模型抽象, 数据以树的形式在内存中排列。 DOM事件 事件三要素 获取事件源： document.getElementById(“box”) document.getElementsByTagName(“div”) 获取的是数组 document.getElementsByName(“aaa”) 获取的是数组 H5之后 绑定事件：事件源.事件 = function(){ 事件驱动程序 }: 匿名绑定 box.onclick = function(){ 程序 }; 函数名绑定 box.onclick = fn; function fn(){ 程序 }; 行内绑定 div id=”box” onclick=”fn()”&gt;&lt;/div; function fn(){ 程序 }; 书写事件驱动程序：关于DOM的操作, 可以操作标签的属性和样式。 事件有哪些 注意: js的加载时和html同步加载的。（如果使用元素在定义元素之间，容易报错）整个页面上所有元素加载完毕再执行js内容，window.onload可以预防使用标签在定义标签之前。 DOM概述","categories":[],"tags":[]},{"title":"冒泡排序","slug":"冒泡排序","date":"2017-05-22T02:35:32.000Z","updated":"2017-05-22T02:47:06.000Z","comments":true,"path":"2017/05/22/冒泡排序/","link":"","permalink":"http://zhulele90.cn/2017/05/22/冒泡排序/","excerpt":"三种冒泡排序的方法","text":"三种冒泡排序的方法 冒泡排序简单版 需求：冒泡排序。 理论：1.比较轮数n-1。 2.比较次数n-1。 3.符合某个条件交换位置。 核心：双重for循环。 步骤： 1.双重for循环。 2.指定轮数和次数 3.判断是否符合标准。如果符合标准交换位置。 12345678910111213141516 var arr = [7,6,5,4,3,2,1];//1.双重for循环。(外循环控制轮数) for(var i=0;i&lt;arr.length-1;i++)&#123; //2.指定轮数和次数（内循环控制次数） for(var j=0;j&lt;arr.length-1;j++)&#123; //3.判断是否符合标准。如果符合标准交换位置。 //从小到大排列顺滑，如果前面的比后面的大，那么交换位置。 if(arr[j] &gt; arr[j+1])&#123; var temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; &#125; &#125; &#125; console.log(arr); 进阶版 每轮比较少比较一次。（每一轮都会比较出一个最大值，然后后一轮没有必要再比较了，所以没比较一轮，就少比较一次。。。） 123456789101112131415161718192021var arr = [7,6,5,4,3,2,1];var m = 0; var n = 0; //1.双重for循环。(外循环控制轮数) for(var i=0;i&lt;arr.length-1;i++)&#123; //2.指定轮数和次数（内循环控制次数） for(var j=0;j&lt;arr.length-1-i;j++)&#123; //3.判断是否符合标准。如果符合标准交换位置。 //从小到大排列顺滑，如果前面的比后面的大，那么交换位置。 if(arr[j] &gt; arr[j+1])&#123; var temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; &#125; m++; &#125; n++; &#125; console.log(arr); console.log(m); console.log(n); 高级版 如果比较完备提前结束比较。（判断，如果本次比较没有移动任何元素，那么说明已经比较完成） 1234567891011121314151617181920212223242526272829var arr = [7,6,5,4,3,2,1];var m = 0; var n = 0; //1.双重for循环。(外循环控制轮数) for(var i=0;i&lt;arr.length-1;i++)&#123; //开闭原则。（写在第一个for循环里，是为了，每轮比较初始化bool变量变为true。） var bool = true; //2.指定轮数和次数（内循环控制次数） for(var j=0;j&lt;arr.length-1-i;j++)&#123; //3.判断是否符合标准。如果符合标准交换位置。 //从小到大排列顺滑，如果前面的比后面的大，那么交换位置。 if(arr[j] &gt; arr[j+1])&#123; var temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; bool = false; &#125; m++; &#125; n++; //bool这个变量默认值为true;如果本轮比较有一对元素相互交换位置，那么也不能跳出循环。 //但是，如果本轮比较没有任何元素相互交换位置，那么说明已经比较完成，可以跳出循环。 if(bool)&#123; break; &#125; &#125; console.log(arr); console.log(m); console.log(n);","categories":[],"tags":[{"name":"冒泡","slug":"冒泡","permalink":"http://zhulele90.cn/tags/冒泡/"}]},{"title":"js第二天","slug":"js第二天","date":"2017-05-16T09:36:49.000Z","updated":"2017-05-17T02:26:06.000Z","comments":true,"path":"2017/05/16/js第二天/","link":"","permalink":"http://zhulele90.cn/2017/05/16/js第二天/","excerpt":"Javascript 书写位置 变量等基础知识","text":"Javascript 书写位置 变量等基础知识 JavaScript 基础02书写位置基本代码: 分号不能省略 123&lt;script type=\"text/javascript\"&gt; &lt;/script&gt; 位置: 内嵌式: 可以放在任意位置, 因为html的编译顺序, 最好放在下面位置: 1234&lt;/body&gt;&lt;/html&gt;&lt;script type=\"text/javascript\"&gt;&lt;/script&gt; 外链式: 1&lt;script src=\"1.js\"&gt;&lt;/script&gt; 将多个JS文件合并成一个文件 输出消息的几种方式 alert comfirm 弹出框 console.log 控制台日志 prompt 接收用户输入信息 document.write 在页面输出信息 可以输出标签 变量变量是用来存储数据的容器 变量的命名规范 不能以数字或者纯数字开头来定义变量名 不推荐使用中文来定义变量名 不能使用特殊符号或者特殊符号开头(-除外) 不推荐使用关键字和保留字来定义变量名 在JS中严格区分大小写的！！！ 数据类型1. 简单数据类型 Number 数字类型 包含正数 负数 小数 字符串 String 凡是用双引号或者单引号引起的都是字符串。 布尔数据类型 Boolean 只有2个值一个是true, 一个是false. 实际运算中true=1,false=0 undefined 变量未初始化 定义了变量，没有给变量赋值 null 变量未引用 值为空 内存中没有 object 2. 复杂数据类型 object 对象 array 数组 3. 判断数据类型typeof() 运算符 比较运算符&lt; &gt; &lt;= &gt;= == != 算术运算符 “+” 加号 两个数字类型的变量相加，得到的是一个数字类型。 一个数字类型和一个字符串相加，得到的是一个字符串。 “—“ 减号 两个数字类型的变量相减，得到的是一个数字类型。 一个数字类型和一个数字字符串相减，得到的是一个数字类型。 一个数字类型和一个非数字字符串相减，得到的是NaN(not a number),是一个数字类型。 “/“ 除号 两个数字类型的变量相除，得到的是一个数字类型。 一个数字类型和一个数字字符串相除，得到的是一个数字类型。 一个数字类型和一个非数字字符串相除，得到的是NaN,是一个数字类型。 0做为除数的时候，得到结果 Infinity （无限大），是一个数字类型。 “%” 取余数 优先级 有()先计算()里边的 Date对象Date对象用于处理日期和时间 12345678910&lt;script type=\"text/javascript\"&gt; var mydate=new Date();//通过new方法创建对象 alert(Date()); // 返回一个完整的日期时间 alert(mydate.getDay());//返回当前是周几 alert(mydate.getMonth()+1);//返回当前月份 alert(mydate.getFullYear());//返回当前年份 alert(mydate.getHours());//返回当前小时 alert(mydate.getMinutes());//返回当前分钟 alert(mydate.getSeconds());//返回当前秒数&lt;/script&gt; Math对象对象123456789101112131415&lt;script type=\"text/javascript\"&gt; var n1=12; var n2=1.23; var n3=3.98; var n4=-12.01; var n5=Math.ceil(n4); //天花板函数 向上去整 var n5=Math.floor(n4); // 向下舍入 var n5=Math.max(n1,n4); //取的是两个数的最大值 var n5=Math.min(n3,n1); //返回是两个数的最小值 var n5=Math.pow(n1,n2); //返回n1的n2次方 var n5=Math.round(n4); // 进行四舍五入操作 var n5=Math.random(); //返回0-1之间的随机数 不包括0和1 alert(n5);&lt;/script&gt; 数据类型转换12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;script type=\"text/javascript\"&gt;var n1=1; var n2=23.45; var n3=-34.1; // 数字转字符串 三种方法 var n1=String(n1);// 数字转字符串 var n5=n2.toString();// 变量转字符串 alert(n5); alert(typeof(n5)); var n1=\"123\"; var n2=\"12abc\"; var n3=\"mylove\"; var n4=\"14期威武\"; var n6=\"-5.93\"; // 字符串转数字 三种方法 /* Number() 1.数字类型的字符串，转换之后得到的数字 2.非数字字符串，转换之后得到是NaN 3.小数类型的字符串，转换之后得到的是原数字 */ var n5=Number(n1); /* parseInt() 1.整数数字类型的字符串，转换之后得到的整数数字。 2.数字开头的字符串，转换之后得到的是前边的数字。 3.非数字开头的字符串，转换之后得到的是NaN。 4.小数类型的字符串，转换之后取整。 */ var n5=parseInt(n1); /* parseFloat() 1.整数数字类型的字符串，转换之后得到的整数数字。 2.数字开头的字符串，转换之后得到的是前边的数字。 3.非数字开头的字符串，转换之后得到的是NaN。 4.小数类型的字符串，转换之后得到的是原数字。 */ var n5=parseFloat(n6); alert(n5); alert(typeof(n5)); var n1=123; var n2=\"345\"; var n3; var n4=null; var n6=0; var n7=Infinity; // 转布尔类型 var n5=Boolean(n7); /* 1.数字和字符串转完之后为true。 2.undefined、null、0转完之后为false. */ alert(n5); alert(typeof(n5)); // 隐式数据类型转换 var n1=12; var n2=\"3\"; var n3=n1-n2; alert(n2); alert(typeof(n2));&lt;/script&gt; 运算符 逻辑运算符 且&amp;&amp; 两个表达式为true的时候，结果为true 或|| 只要有一个表达式为true,结果为true 非！ 和表达式相反的结果 等号运算符 “=”赋值运算符 “==”只判断内容是否相同，不判断数据类型。 “===”不仅判断内容，还判断数据类型是否相同。 ！= 只判断内容是否不相同，不判断数据类型。 ！==不全等于 不仅判断内容是否不相同，还判断数据类型是否不相同。 变量的集体声明1var n1=1,n2=2,n3=3;n1+=n2;//变量的集体声明 几种语句 switch语句 123456789101112131415161718192021222324252627var fruit=prompt(\"请输入您喜欢吃的水果\");// switch后边的变量和case后边值的数据类型必须保持一致 switch(fruit)&#123; case \"苹果\": alert(\"您喜欢吃的是苹果\"); break; //阻断代码执行 case \"香蕉\": alert(\"您喜欢吃的是香蕉\"); break; case \"葡萄\": alert(\"您喜欢吃的是葡萄\"); break; default: alert(\"口味真重\"); break; &#125; // 可以对变量进行集体判断 switch(fruit)&#123; case \"苹果\": case \"香蕉\": case \"葡萄\":// case值的集体声明 alert(\"您喜欢吃水果\"); break; default: alert(\"口味真重\"); break; &#125; 自增自减 i++ ++i –i i– 1234567891011var n1=123;// 在不参与运算的情况下，i++和++i都是在变量的基础加1n1++; //==&gt;n1=n1+1; 在变量原来的基础上加1++n1; //==&gt;n1=n1+1; 在变量原来的基础上加1alert(n1);// 在参与运算的情况下var n1=123;var n2=n1++; //先将n1赋值给n2，之后n1再自增var n2=++n1; //n1先自增，在赋值给n2alert(n2);alert(n1); 数组12345678910111213141516171819202122232425262728293031&lt;script type=\"text/javascript\"&gt; // 数组的定义 var ary1=new Array(); //用new方法来创建一个数组 var ary1=[]; //直接创建一个数组 ary1[0]=12; //通过下标给数组赋值 ary1[1]=23; ary1[2]=\"中国人\"; ary1[3]=\"美国人\"; alert(ary1); //显示数组 //数组的初始化 var ary1=[12,23,45,\"中国人\",\"34\"]; alert(ary1); // 数组的遍历 for(var i=0; i&lt;5; i++)&#123; alert(ary1[i]); &#125; // length属性代表数组数据的个数 var ary=[1,\"2k\",\"e3\",43,23,23,54,65,\"y5\",\"y6\",7]; for(var i=0;i&lt;ary.length; i++)&#123; alert(ary[i]); &#125; var ary1=[2,23,32,21,345,46]; var ary2=[2,3,4,8,12,\"来两串\"]; // 数组的合并 var ary3=ary1.concat(ary2); // 返回一个数组 alert(ary3); var ary1=[2,23,32,21,345,46,\"中国人\"]; var ary2=ary1.join(\"&amp;\"); // 返回一个字符串 alert(ary2); alert(typeof(ary2)); &lt;/script&gt; 函数1234function test()&#123; //通过function创建函数 alert(\"乐乐牛\"); &#125; test(); //函数调用","categories":[],"tags":[{"name":"1","slug":"1","permalink":"http://zhulele90.cn/tags/1/"}]},{"title":"js第一天","slug":"js第一天","date":"2017-05-15T14:54:13.000Z","updated":"2017-05-17T02:26:50.000Z","comments":true,"path":"2017/05/15/js第一天/","link":"","permalink":"http://zhulele90.cn/2017/05/15/js第一天/","excerpt":"Javascript 历史 特点等基础知识","text":"Javascript 历史 特点等基础知识 JavaScript基础(Day1)JavaScript历史34岁的系统程序员Brendan Eich（布兰登·艾奇）, 1995年4月, 网景公司录用了他, 1995年5月他只用10天时间就把Javascript设计出来. 1995.2月 Netscape公司发布LiveScript，后临时改为JavaScript，为了赶上Java的热浪 1997 年，以JavaScript 1.1 为基础。由来自 Netscape、Sun、微软、Borland 和其他一些对脚本编程感兴趣的公司的程序员组成的 TC39（ECMA的小组） 锤炼出了 ECMA-262，也就是ECMAScript1.0。 1998年6月，ECMAScript 2.0版发布。 1999年12月，ECMAScript 3.0版发布，成为JavaScript的通行标准，得到了广泛支持. 2007年10月，ECMAScript 4.0版草案发布：分歧太大，失败告终。 2009年12月，ECMAScript 5.0版正式发布. 2015年6月17日，ECMAScript 6发布正式版本，即ECMAScript 2015。 认识JavaScriptJavaScript是一种网页编程技术, 就是一种基于对象和事件驱动，并具有安全性能的脚本语言,可以被嵌入到HTML文件中，不需要经过Web服务器就可以对用户操作作出响应. 组成 ECMAScript：JavaScript的语法标准。 DOM：JavaScript操作网页上的元素的API BOM：JavaScript操作浏览器的部分功能的API 特点 简单易用 可以使用任何文本编辑工具编写 只需要浏览器就可以执行程序 解释执行（解释语言） 事先不编译 逐行执行 无需进行严格的变量声明 基于对象 内置大量现成对象，编写少量程序可以完成目标","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://zhulele90.cn/tags/Javascript/"}]}]}