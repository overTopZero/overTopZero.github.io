{"meta":{"title":"Craco的博客","subtitle":"一个热爱编程的程序猿","description":"辽宁科技大学08级, 就职于上海宏驰, 擅长iOS, web前端, 非专业视觉设计师。此为博客一枚。","author":"Craco","url":"http://zhulele90.cn"},"pages":[],"posts":[{"title":"js第二天","slug":"js第二天","date":"2017-05-16T09:36:49.000Z","updated":"2017-05-16T10:16:12.000Z","comments":true,"path":"2017/05/16/js第二天/","link":"","permalink":"http://zhulele90.cn/2017/05/16/js第二天/","excerpt":"","text":"JavaScript 基础02书写位置基本代码: 分号不能省略 123&lt;script type=\"text/javascript\"&gt; &lt;/script&gt; 位置: 内嵌式: 可以放在任意位置, 因为html的编译顺序, 最好放在下面位置: 1234&lt;/body&gt;&lt;/html&gt;&lt;script type=\"text/javascript\"&gt;&lt;/script&gt; 外链式: 1&lt;script src=\"1.js\"&gt;&lt;/script&gt; 将多个JS文件合并成一个文件 输出消息的几种方式 alert comfirm 弹出框 console.log 控制台日志 prompt 接收用户输入信息 document.write 在页面输出信息 可以输出标签 变量变量是用来存储数据的容器 变量的命名规范 不能以数字或者纯数字开头来定义变量名 不推荐使用中文来定义变量名 不能使用特殊符号或者特殊符号开头(-除外) 不推荐使用关键字和保留字来定义变量名 在JS中严格区分大小写的！！！ 数据类型1. 简单数据类型 Number 数字类型 包含正数 负数 小数 字符串 String 凡是用双引号或者单引号引起的都是字符串。 布尔数据类型 Boolean 只有2个值一个是true, 一个是false. 实际运算中true=1,false=0 undefined 变量未初始化 定义了变量，没有给变量赋值 null 变量未引用 值为空 内存中没有 object 2. 复杂数据类型 object 对象 array 数组 3. 判断数据类型typeof() 运算符 比较运算符&lt; &gt; &lt;= &gt;= == != 算术运算符 “+” 加号 两个数字类型的变量相加，得到的是一个数字类型。 一个数字类型和一个字符串相加，得到的是一个字符串。 “—“ 减号 两个数字类型的变量相减，得到的是一个数字类型。 一个数字类型和一个数字字符串相减，得到的是一个数字类型。 一个数字类型和一个非数字字符串相减，得到的是NaN(not a number),是一个数字类型。 “/“ 除号 两个数字类型的变量相除，得到的是一个数字类型。 一个数字类型和一个数字字符串相除，得到的是一个数字类型。 一个数字类型和一个非数字字符串相除，得到的是NaN,是一个数字类型。 0做为除数的时候，得到结果 Infinity （无限大），是一个数字类型。 “%” 取余数 优先级 有()先计算()里边的 Date对象Date对象用于处理日期和时间 12345678910&lt;script type=\"text/javascript\"&gt; var mydate=new Date();//通过new方法创建对象 alert(Date()); // 返回一个完整的日期时间 alert(mydate.getDay());//返回当前是周几 alert(mydate.getMonth()+1);//返回当前月份 alert(mydate.getFullYear());//返回当前年份 alert(mydate.getHours());//返回当前小时 alert(mydate.getMinutes());//返回当前分钟 alert(mydate.getSeconds());//返回当前秒数&lt;/script&gt; Math对象对象123456789101112131415&lt;script type=\"text/javascript\"&gt; var n1=12; var n2=1.23; var n3=3.98; var n4=-12.01; var n5=Math.ceil(n4); //天花板函数 向上去整 var n5=Math.floor(n4); // 向下舍入 var n5=Math.max(n1,n4); //取的是两个数的最大值 var n5=Math.min(n3,n1); //返回是两个数的最小值 var n5=Math.pow(n1,n2); //返回n1的n2次方 var n5=Math.round(n4); // 进行四舍五入操作 var n5=Math.random(); //返回0-1之间的随机数 不包括0和1 alert(n5);&lt;/script&gt; 数据类型转换12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;script type=\"text/javascript\"&gt;var n1=1; var n2=23.45; var n3=-34.1; // 数字转字符串 三种方法 var n1=String(n1);// 数字转字符串 var n5=n2.toString();// 变量转字符串 alert(n5); alert(typeof(n5)); var n1=\"123\"; var n2=\"12abc\"; var n3=\"mylove\"; var n4=\"14期威武\"; var n6=\"-5.93\"; // 字符串转数字 三种方法 /* Number() 1.数字类型的字符串，转换之后得到的数字 2.非数字字符串，转换之后得到是NaN 3.小数类型的字符串，转换之后得到的是原数字 */ var n5=Number(n1); /* parseInt() 1.整数数字类型的字符串，转换之后得到的整数数字。 2.数字开头的字符串，转换之后得到的是前边的数字。 3.非数字开头的字符串，转换之后得到的是NaN。 4.小数类型的字符串，转换之后取整。 */ var n5=parseInt(n1); /* parseFloat() 1.整数数字类型的字符串，转换之后得到的整数数字。 2.数字开头的字符串，转换之后得到的是前边的数字。 3.非数字开头的字符串，转换之后得到的是NaN。 4.小数类型的字符串，转换之后得到的是原数字。 */ var n5=parseFloat(n6); alert(n5); alert(typeof(n5)); var n1=123; var n2=\"345\"; var n3; var n4=null; var n6=0; var n7=Infinity; // 转布尔类型 var n5=Boolean(n7); /* 1.数字和字符串转完之后为true。 2.undefined、null、0转完之后为false. */ alert(n5); alert(typeof(n5)); // 隐式数据类型转换 var n1=12; var n2=\"3\"; var n3=n1-n2; alert(n2); alert(typeof(n2));&lt;/script&gt; 运算符 逻辑运算符 且&amp;&amp; 两个表达式为true的时候，结果为true 或|| 只要有一个表达式为true,结果为true 非！ 和表达式相反的结果 等号运算符 “=”赋值运算符 “==”只判断内容是否相同，不判断数据类型。 “===”不仅判断内容，还判断数据类型是否相同。 ！= 只判断内容是否不相同，不判断数据类型。 ！==不全等于 不仅判断内容是否不相同，还判断数据类型是否不相同。 变量的集体声明1var n1=1,n2=2,n3=3;n1+=n2;//变量的集体声明 几种语句 switch语句 123456789101112131415161718192021222324252627var fruit=prompt(\"请输入您喜欢吃的水果\");// switch后边的变量和case后边值的数据类型必须保持一致 switch(fruit)&#123; case \"苹果\": alert(\"您喜欢吃的是苹果\"); break; //阻断代码执行 case \"香蕉\": alert(\"您喜欢吃的是香蕉\"); break; case \"葡萄\": alert(\"您喜欢吃的是葡萄\"); break; default: alert(\"口味真重\"); break; &#125; // 可以对变量进行集体判断 switch(fruit)&#123; case \"苹果\": case \"香蕉\": case \"葡萄\":// case值的集体声明 alert(\"您喜欢吃水果\"); break; default: alert(\"口味真重\"); break; &#125; 自增自减 i++ ++i –i i– 1234567891011var n1=123;// 在不参与运算的情况下，i++和++i都是在变量的基础加1n1++; //==&gt;n1=n1+1; 在变量原来的基础上加1++n1; //==&gt;n1=n1+1; 在变量原来的基础上加1alert(n1);// 在参与运算的情况下var n1=123;var n2=n1++; //先将n1赋值给n2，之后n1再自增var n2=++n1; //n1先自增，在赋值给n2alert(n2);alert(n1); 数组12345678910111213141516171819202122232425262728293031&lt;script type=\"text/javascript\"&gt; // 数组的定义 var ary1=new Array(); //用new方法来创建一个数组 var ary1=[]; //直接创建一个数组 ary1[0]=12; //通过下标给数组赋值 ary1[1]=23; ary1[2]=\"中国人\"; ary1[3]=\"美国人\"; alert(ary1); //显示数组 //数组的初始化 var ary1=[12,23,45,\"中国人\",\"34\"]; alert(ary1); // 数组的遍历 for(var i=0; i&lt;5; i++)&#123; alert(ary1[i]); &#125; // length属性代表数组数据的个数 var ary=[1,\"2k\",\"e3\",43,23,23,54,65,\"y5\",\"y6\",7]; for(var i=0;i&lt;ary.length; i++)&#123; alert(ary[i]); &#125; var ary1=[2,23,32,21,345,46]; var ary2=[2,3,4,8,12,\"来两串\"]; // 数组的合并 var ary3=ary1.concat(ary2); // 返回一个数组 alert(ary3); var ary1=[2,23,32,21,345,46,\"中国人\"]; var ary2=ary1.join(\"&amp;\"); // 返回一个字符串 alert(ary2); alert(typeof(ary2)); &lt;/script&gt; 函数1234function test()&#123; //通过function创建函数 alert(\"乐乐牛\"); &#125; test(); //函数调用","categories":[],"tags":[{"name":"1","slug":"1","permalink":"http://zhulele90.cn/tags/1/"}]},{"title":"js第一天","slug":"js第一天","date":"2017-05-15T14:54:13.000Z","updated":"2017-05-16T10:16:19.000Z","comments":true,"path":"2017/05/15/js第一天/","link":"","permalink":"http://zhulele90.cn/2017/05/15/js第一天/","excerpt":"","text":"JavaScript基础(Day1)JavaScript历史34岁的系统程序员Brendan Eich（布兰登·艾奇）, 1995年4月, 网景公司录用了他, 1995年5月他只用10天时间就把Javascript设计出来. 1995.2月 Netscape公司发布LiveScript，后临时改为JavaScript，为了赶上Java的热浪 1997 年，以JavaScript 1.1 为基础。由来自 Netscape、Sun、微软、Borland 和其他一些对脚本编程感兴趣的公司的程序员组成的 TC39（ECMA的小组） 锤炼出了 ECMA-262，也就是ECMAScript1.0。 1998年6月，ECMAScript 2.0版发布。 1999年12月，ECMAScript 3.0版发布，成为JavaScript的通行标准，得到了广泛支持. 2007年10月，ECMAScript 4.0版草案发布：分歧太大，失败告终。 2009年12月，ECMAScript 5.0版正式发布. 2015年6月17日，ECMAScript 6发布正式版本，即ECMAScript 2015。 认识JavaScriptJavaScript是一种网页编程技术, 就是一种基于对象和事件驱动，并具有安全性能的脚本语言,可以被嵌入到HTML文件中，不需要经过Web服务器就可以对用户操作作出响应. 组成 ECMAScript：JavaScript的语法标准。 DOM：JavaScript操作网页上的元素的API BOM：JavaScript操作浏览器的部分功能的API 特点 简单易用 可以使用任何文本编辑工具编写 只需要浏览器就可以执行程序 解释执行（解释语言） 事先不编译 逐行执行 无需进行严格的变量声明 基于对象 内置大量现成对象，编写少量程序可以完成目标","categories":[],"tags":[{"name":"1","slug":"1","permalink":"http://zhulele90.cn/tags/1/"}]},{"title":"iOS笔记","slug":"iOS笔记","date":"2017-05-15T09:48:27.000Z","updated":"2017-05-16T10:16:25.000Z","comments":true,"path":"2017/05/15/iOS笔记/","link":"","permalink":"http://zhulele90.cn/2017/05/15/iOS笔记/","excerpt":"","text":"NSTimer定义123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** 这下面主要是一些构造方法*///1. 创建一个定时器，但是么有添加到运行循环，我们需要在创建定时器后手动的调用 NSRunLoop 对象的 addTimer:forMode: 方法。+ (NSTimer *)timerWithTimeInterval:(NSTimeInterval)ti invocation:(NSInvocation *)invocation repeats:(BOOL)yesOrNo;//2. 创建一个timer并把它指定到一个默认的runloop模式中，并且在 TimeInterval时间后 启动定时器+ (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)ti invocation:(NSInvocation *)invocation repeats:(BOOL)yesOrNo; //3. 创建一个定时器，但是么有添加到运行循环，我们需要在创建定时器后手动的调用 NSRunLoop 对象的 addTimer:forMode: 方法。+ (NSTimer *)timerWithTimeInterval:(NSTimeInterval)ti target:(id)aTarget selector:(SEL)aSelector userInfo:(nullable id)userInfo repeats:(BOOL)yesOrNo;//3. 创建一个timer并把它指定到一个默认的runloop模式中，并且在 TimeInterval时间后 启动定时器+ (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)ti target:(id)aTarget selector:(SEL)aSelector userInfo:(nullable id)userInfo repeats:(BOOL)yesOrNo;//4. 默认的初始化方法，（创建定时器后，手动添加到 运行循环，并且手动触发才会启动定时器）- (instancetype)initWithFireDate:(NSDate *)date interval:(NSTimeInterval)ti target:(id)t selector:(SEL)s userInfo:(nullable id)ui repeats:(BOOL)rep NS_DESIGNATED_INITIALIZER;// 启动 Timer 触发Target的方法调用但是并不会改变Timer的时间设置。 即 time没有到达到，Timer会立即启动调用方法且没有改变时间设置，当时间 time 到了的时候，Timer还是会调用方法。- (void)fire;// 这是设置定时器的启动时间，常用来管理定时器的启动与停止@property (copy) NSDate *fireDate;// 启动定时器 timer.fireDate = [NSDate distantPast]; //停止定时器 timer.fireDate = [NSDate distantFuture];// 开启 [time setFireDate:[NSDate distanPast]]// NSTimer 关闭 ［time setFireDate:[NSDate distantFunture]］//继续。[timer setFireDate:[NSDate date]]; // 这个是一个只读属性，获取定时器调用间隔时间@property (readonly) NSTimeInterval timeInterval;// 这是7.0之后新增的一个属性，因为NSTimer并不完全精准，通过这个值设置误差范围@property NSTimeInterval tolerance NS_AVAILABLE(10_9, 7_0);// 停止 Timer ---&gt; 唯一的方法将定时器从循环池中移除- (void)invalidate;// 获取定时器是否有效@property (readonly, getter=isValid) BOOL valid;// 获取参数信息---&gt; 通常传入的是 nil@property (nullable, readonly, retain) id userInfo; NSTimer 使用过程中的问题：1.内存释放问题 如果我们启动了一个定时器，在某个界面释放前，将这个定时器停止，甚至置为nil，都不能使这个界面释放，原因是系统的循环池中还保有这个对象。（ timer都会对它的target进行retain，我们需要小心对待这个target的生命周期问题，尤其是重复性的timer） 所以需要这么做: 123456789101112131415161718192021-(void)dealloc&#123;NSLog(@&quot;dealloc:%@&quot;,[self class]);&#125;- (void)viewDidLoad &#123;[super viewDidLoad];timer= [NSTimer scheduledTimerWithTimeInterval:1 target:self selector:@selector(myLog:) userInfo:nil repeats:YES];UIButton *btn = [[UIButton alloc]initWithFrame:CGRectMake(0, 0, 100, 100)];btn.backgroundColor=[UIColor redColor];[btn addTarget:self action:@selector(btn) forControlEvents:UIControlEventTouchUpInside];[self.view addSubview:btn];&#125;-(void)btn&#123; if (timer.isValid) &#123; [timer invalidate]; // 从运行循环中移除， 对运行循环的引用进行一次 releasetimer=nil; // 将销毁定时器&#125;[self dismissViewControllerAnimated:YES completion:nil];&#125; 2.NSTimer为什么要添加到RunLoop中才会有作用？ 便利构造器，它其实是做了两件事：首先创建一个timer，然后将该timer添加到当前runloop的default mode中。 也就是这个便利方法给我们造成了只要创建了timer就可以生效的错觉，我们当然可以自己创建timer，然后手动的把它添加到指定runloop的指定mode中去。 NSTimer其实也是一种资源（事件），如果看过多线程变成指引文档的话，我们会发现所有的source（事件）如果要起作用，就得加到runloop中去。同理timer这种资源要想起作用，那肯定也需要加到runloop中才会有效喽。如果一个runloop里面不包含任何资源（事件）的话，运行该runloop时会处于一种休眠状态等待下一个事件。 注意： 必须得把timer添加到runloop中，它才会生效。 3.NSTimer加到了RunLoop中但迟迟的不触发事件?原因主要有两个: runloop是否运行? 123// 每一个线程都有它自己的runloop，程序的主线程会自动的使runloop生效，但对于我们自己新建的线程，它的runloop是不会自己运行起来，当我们需要使用它的runloop时，就得自己启动。// 打开下面一行, 该线程的runloop就会运行起来，timer才会起作用[[NSRunLoop currentRunLoop] runUntilDate:[NSDate dateWithTimeIntervalSinceNow:3]]; mode是否正确?前面提到了要想timer生效，我们就得把它添加到指定runloop的指定mode中去，通常是主线程的defalut mode。但有时我们这样做了，却仍然发现timer还是没有触发事件。这是因为timer添加的时候，我们需要指定一个mode，因为同一线程的runloop在运行的时候，任意时刻只能处于一种mode。所以只能当程序处于这种mode的时候，timer才能得到触发事件的机会。 综上: 要让timer生效，必须保证该线程的runloop已启动，而且其运行的runloopmode也要匹配。 注意点: [timer invalidate]是唯一的方法将定时器从循环池中移除 NSTimer可以精确到50-100毫秒. NSTimeInterval类：是一个浮点数字，用来定义秒 NSTimer不是绝对准确的,而且中间耗时或阻塞错过下一个点,那么下一个点就pass过去了. CADisplayLink 什么是CADisplayLink？ CADisplayLink是一个能让我们以和屏幕刷新率相同的频率将内容画到屏幕上的定时器。我们在应用中创建一个新的 CADisplayLink 对象，把它添加到一个runloop中，并给它提供一个 target 和selector 在屏幕刷新的时候调用。 一但 CADisplayLink 以特定的模式注册到runloop之后，每当屏幕需要刷新的时候，runloop就会调用CADisplayLink绑定的target上的selector，这时target可以读到 CADisplayLink 的每次调用的时间戳，用来准备下一帧显示需要的数据。例如一个视频应用使用时间戳来计算下一帧要显示的视频数据。在UI做动画的过程中，需要通过时间戳来计算UI对象在动画的下一帧要更新的大小等等。 在添加进runloop的时候我们应该选用高一些的优先级，来保证动画的平滑。可以设想一下，我们在动画的过程中，runloop被添加进来了一个高优先级的任务，那么，下一次的调用就会被暂停转而先去执行高优先级的任务，然后在接着执行CADisplayLink的调用，从而造成动画过程的卡顿，使动画不流畅。 duration属性提供了每帧之间的时间，也就是屏幕每次刷新之间的的时间。我们可以使用这个时间来计算出下一帧要显示的UI的数值。但是 duration只是个大概的时间，如果CPU忙于其它计算，就没法保证以相同的频率执行屏幕的绘制操作，这样会跳过几次调用回调方法的机会。 frameInterval属性是可读可写的NSInteger型值，标识间隔多少帧调用一次selector 方法，默认值是1，即每帧都调用一次。如果每帧都调用一次的话，对于iOS设备来说那刷新频率就是60HZ也就是每秒60次，如果将 frameInterval 设为2 那么就会两帧调用一次，也就是变成了每秒刷新30次。 我们通过pause属性开控制CADisplayLink的运行。当我们想结束一个CADisplayLink的时候，应该调用-(void)invalidate从runloop中删除并删除之前绑定的 target跟selector 另外CADisplayLink 不能被继承 CADisplayLink 与 NSTimer 有什么不同？ iOS设备的屏幕刷新频率是固定的，CADisplayLink在正常情况下会在每次刷新结束都被调用，精确度相当高。 NSTimer的精确度就显得低了点，比如NSTimer的触发时间到的时候，runloop如果在阻塞状态，触发时间就会推迟到下一个runloop周期。并且 NSTimer新增了tolerance属性，让用户可以设置可以容忍的触发的时间的延迟范围。 CADisplayLink使用场合相对专一，适合做UI的不停重绘，比如自定义动画引擎或者视频播放的渲染。NSTimer的使用范围要广泛的多，各种需要单次或者循环定时处理的任务都可以使用。在UI相关的动画或者显示内容使用 CADisplayLink比起用NSTimer的好处就是我们不需要在格外关心屏幕的刷新频率了，因为它本身就是跟屏幕刷新同步的。 CADisplayLink使用的例子 12345678910111213self.displayLink = [CADisplayLink displayLinkWithTarget:self selector:@selector(updateTextColor)];self.displayLink.paused = YES;[self.displayLink addToRunLoop:[NSRunLoop currentRunLoop] forMode:NSRunLoopCommonModes];-(void)updateTextColor&#123;&#125;- (void)startAnimation&#123;self.beginTime = CACurrentMediaTime();self.displayLink.paused = NO;&#125;- (void)stopAnimation&#123;self.displayLink.paused = YES;[self.displayLink invalidate];self.displayLink = nil;&#125; 注意：iOS设备的刷新频率事60HZ也就是每秒60次。那么每一次刷新的时间就是1/60秒 大概16.7毫秒。当我们的frameInterval值为1的时候我们需要保证的是 CADisplayLink调用的｀target｀的函数计算时间不应该大于 16.7否则就会出现严重的丢帧现象。 GCD定时器 定义 12/** 定时器(这里不用带*，因为dispatch_source_t就是个类，内部已经包含了*) 这是一个OC对象 */@property (nonatomic, strong) dispatch_source_t timer; 创建 1234// 获得队列dispatch_queue_t queue = dispatch_get_main_queue();// 创建一个定时器(dispatch_source_t本质还是个OC对象)self.timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue); 设置参数 1234567// 设置定时器的各种属性（几时开始任务，每隔多长时间执行一次）// GCD的时间参数，一般是纳秒（1秒 == 10的9次方纳秒）// 何时开始执行第一个任务// dispatch_time(DISPATCH_TIME_NOW, 1.0 * NSEC_PER_SEC) 比当前时间晚3秒dispatch_time_t start = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1.0 * NSEC_PER_SEC));uint64_t interval = (uint64_t)(1.0 * NSEC_PER_SEC);dispatch_source_set_timer(self.timer, start, interval, 0); 设置回调 1234567891011// 设置回调dispatch_source_set_event_handler(self.timer, ^&#123;NSLog(@&quot;------------%@&quot;, [NSThread currentThread]);count++;// if (count == 4) &#123;// // 取消定时器// dispatch_source_cancel(self.timer);// self.timer = nil;// &#125;&#125;); 启动定时器 1dispatch_resume(self.timer); 注意： GCD的定时器和NSTimer是不一样的，NSTimer受RunLoop影响，但是GCD的定时器不受影响，因为RunLoop也是基于GCD的（源代码可知）。 注：资料多是自己网上摘抄整理的，记录下来以便学习查询之用，严格原创出处不便考证以注明，若有侵权实属无意，敬请见谅！ 不严谨! 条件所限，很多知识点现在还吃不透，日后发现错误再做修改。","categories":[],"tags":[{"name":"1","slug":"1","permalink":"http://zhulele90.cn/tags/1/"}]}]}